<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal Trading | Probabilidad & Gestión | FTI</title>
    <meta name="theme-color" content="#2563eb">
    <link rel="icon" href="/pwa/logo-app.png">

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        slate: {
                            850: '#1e293b',
                            900: '#0f172a',
                        }
                    }
                }
            }
        }
    </script>

    <!-- Script Anti-Flash de Tema -->
    <script>
            (function () {
                try {
                    const storedTheme = localStorage.getItem('fti_theme_preference');
                    const systemDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

                    if (storedTheme === 'dark' || ((!storedTheme || storedTheme === 'system') && systemDark)) {
                        document.documentElement.classList.add('dark');
                    } else {
                        document.documentElement.classList.remove('dark');
                    }
                } catch (e) {
                    console.warn('Error accediendo a localStorage para tema:', e);
                }
            })();
    </script>

    <!-- Google Font: Inter & JetBrains Mono -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <!-- html2canvas -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .font-mono {
            font-family: 'JetBrains Mono', monospace;
        }

        @keyframes fade-in {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-fade-in {
            animation: fade-in 0.5s ease-out forwards;
        }

        /* Animaciones suaves */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-fade-in {
            animation: fadeIn 0.4s ease-out forwards;
        }

        /* Detalles desplegables */
        details[open] summary~* {
            animation: fadeIn 0.3s ease-in-out;
        }

        details[open] .group-open\:rotate-180 {
            transform: rotate(180deg);
        }
    </style>
</head>

<body class="bg-slate-50 dark:bg-slate-950 text-slate-900 dark:text-slate-200 transition-colors duration-300">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef, useCallback } = React;

        const POPULAR_PAIRS = [
            "BTCUSDT", "ETHUSDT", "ETCUSDT", "LTCUSDT", "XRPUSDT",
            "SOLUSDT", "TRXUSDT", "MATICUSDT", "DASHUSDT", "QTUMUSDT",
            "ZECUSDT", "NOTUSDT", "AUSDT",
            "BNBUSDT", "ADAUSDT", "DOGEUSDT", "AVAXUSDT", "DOTUSDT",
            "LINKUSDT", "BCHUSDT", "XLMUSDT", "NEARUSDT", "ATOMUSDT",
            "UNIUSDT", "FILUSDT", "HBARUSDT", "PEPEUSDT", "SHIBUSDT",
            "SUIUSDT", "APTUSDT", "ARBUSDT", "POLUSDT"
        ];

        const FOREX_PAIRS = [
            "XAU/USD", "XAUUSD",
            "EUR/USD", "USD/JPY", "GBP/USD", "AUD/USD", "USD/CAD",
            "USD/CHF", "NZD/USD", "EUR/JPY", "EUR/GBP", "GBP/JPY",
            "AUD/JPY", "CAD/JPY", "CHF/JPY"
        ];

        const AUTOLOAD_ENTRY_TFS = [
            { label: '15M', interval: '15m' },
            { label: '1H', interval: '1h' },
            { label: '4H', interval: '4h' },
            { label: '1D', interval: '1d' }
        ];

        const AUTOLOAD_TF_MAP = {
            '1h': { htf: '4h', ltf: '15m' },
            '4h': { htf: '1d', ltf: '1h' },
            '1d': { htf: '1w', ltf: '4h' }
        };

        const AUTOLOAD_TF_LABEL = {
            '5m': '5m',
            '15m': '15m',
            '1h': '1H',
            '4h': '4H',
            '1d': '1D',
            '1w': '1W'
        };
        const IconBase = ({ children, size = 20, className = "", ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
        );

        const Icons = {
            Upload: (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" x2="12" y1="3" y2="15" /></IconBase>,
            Play: (p) => <IconBase {...p}><polygon points="5 3 19 12 5 21 5 3" /></IconBase>,

            AlertCircle: (p) => <IconBase {...p}><circle cx="12" cy="12" r="10" /><line x1="12" x2="12" y1="8" y2="12" /><line x1="12" x2="12.01" y1="16" y2="16" /></IconBase>,
            CheckCircle: (p) => <IconBase {...p}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" /><polyline points="22 4 12 14.01 9 11.01" /></IconBase>,
            Activity: (p) => <IconBase {...p}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12" /></IconBase>,
            Sun: (p) => <IconBase {...p}><circle cx="12" cy="12" r="5" /><line x1="12" y1="1" x2="12" y2="3" /><line x1="12" y1="21" x2="12" y2="23" /><line x1="4.22" y1="4.22" x2="5.64" y2="5.64" /><line x1="18.36" y1="18.36" x2="19.78" y2="19.78" /><line x1="1" y1="12" x2="3" y2="12" /><line x1="21" y1="12" x2="23" y2="12" /><line x1="4.22" y1="19.78" x2="5.64" y2="18.36" /><line x1="18.36" y1="5.64" x2="19.78" y2="4.22" /></IconBase>,
            AlertTriangle: (p) => <IconBase {...p}><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" /><line x1="12" y1="9" x2="12" y2="13" /><line x1="12" y1="17" x2="12.01" y2="17" /></IconBase>,
            Stethoscope: (p) => <IconBase {...p}><path d="M6 2v6a6 6 0 0 0 12 0V2" /><path d="M8 2v6a4 4 0 0 0 8 0V2" /><path d="M12 14v2a4 4 0 0 0 8 0v-1" /><circle cx="20" cy="15" r="2" /></IconBase>,
            Target: (p) => <IconBase {...p}><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" /></IconBase>,
            ShieldAlert: (p) => <IconBase {...p}><path d="M12 22s8-4 8-10V5L12 2 4 5v7c0 6 8 10 8 10" /><line x1="12" x2="12" y1="8" y2="12" /><line x1="12" x2="12.01" y1="16" y2="16" /></IconBase>,
            ShieldCheck: (p) => <IconBase {...p}><path d="M12 22s8-4 8-10V5L12 2 4 5v7c0 6 8 10 8 10" /><polyline points="9 12 12 15 15 10" /></IconBase>,
            BarChart3: (p) => <IconBase {...p}><path d="M3 3v18h18" /><path d="M18 17V9" /><path d="M13 17V5" /><path d="M8 17v-3" /></IconBase>,
            Clock: (p) => <IconBase {...p}><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></IconBase>,

            TrendingUp: (p) => <IconBase {...p}><polyline points="23 6 13.5 15.5 8.5 10.5 1 18" /><polyline points="17 6 23 6 23 12" /></IconBase>,
            History: (p) => <IconBase {...p}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12" /><path d="M3 3v9h9" /><path d="M12 7v5l3 3" /></IconBase>,
            Lock: (p) => <IconBase {...p}><rect x="3" y="11" width="18" height="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 10 0v4" /></IconBase>,

            Zap: (p) => <IconBase {...p}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" /></IconBase>,
            FileText: (p) => <IconBase {...p}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" /><polyline points="14 2 14 8 20 8" /></IconBase>,
            Camera: (p) => <IconBase {...p}><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" /><circle cx="12" cy="13" r="4" /></IconBase>,
            HelpCircle: (p) => <IconBase {...p}><circle cx="12" cy="12" r="10" /><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" /><line x1="12" x2="12.01" y1="17" y2="17" /></IconBase>,
            Map: (p) => <IconBase {...p}><polygon points="3 6 9 3 15 6 21 3 21 18 15 21 9 18 3 21 3 6" /><line x1="9" x2="9" y1="3" y2="18" /><line x1="15" x2="15" y1="6" y2="21" /></IconBase>,
            ChevronDown: (p) => <IconBase {...p}><polyline points="6 9 12 15 18 9" /></IconBase>,
            ChevronLeft: (p) => <IconBase {...p}><polyline points="15 18 9 12 15 6" /></IconBase>,
            ChevronRight: (p) => <IconBase {...p}><polyline points="9 18 15 12 9 6" /></IconBase>,
            Trash2: (p) => <IconBase {...p}><polyline points="3 6 5 6 21 6" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /><line x1="10" y1="11" x2="10" y2="17" /><line x1="14" y1="11" x2="14" y2="17" /></IconBase>,
            Split: (p) => <IconBase {...p}><path d="M12 3v18" /><path d="M4 7h5" /><path d="M15 7h5" /><path d="M4 17h5" /><path d="M15 17h5" /><path d="M4 12h16" /></IconBase>,
            Calendar: (p) => <IconBase {...p}><rect x="3" y="4" width="18" height="18" rx="2" ry="2" /><line x1="16" y1="2" x2="16" y2="6" /><line x1="8" y1="2" x2="8" y2="6" /><line x1="3" y1="10" x2="21" y2="10" /></IconBase>,
            Edit2: (p) => <IconBase {...p}><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z" /></IconBase>,
            Shield: (p) => <IconBase {...p}><path d="M12 22s8-4 8-10V5L12 2 4 5v7c0 6 8 10 8 10" /></IconBase>,
            Eye: (p) => <IconBase {...p}><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" /><circle cx="12" cy="12" r="3" /></IconBase>
        };

        const AUDIT_VARIANTS = {
            INSUFFICIENTE: {
                container: 'bg-slate-100 dark:bg-slate-900/40 border-slate-300 dark:border-slate-700 text-slate-600',
                message: 'Datos Insuficientes',
                icon: Icons.HelpCircle
            },
            FRAGIL: {
                container: 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 text-red-600 dark:text-red-400',
                message: 'Estructura Frágil',
                icon: Icons.Activity
            },
            NEGATIVO: {
                container: 'bg-rose-50 dark:bg-rose-900/20 border-rose-200 dark:border-rose-800 text-rose-600 dark:text-rose-400',
                message: 'Edge Negativo',
                icon: Icons.AlertCircle
            },
            ESPECULATIVO: {
                container: 'bg-orange-50 dark:bg-orange-900/20 border-orange-200 dark:border-orange-800 text-orange-600 dark:text-orange-400',
                message: 'Edge Especulativo',
                icon: Icons.ShieldAlert
            },
            ROBUSTO: {
                container: 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-200 dark:border-emerald-800 text-emerald-600 dark:text-emerald-400',
                message: 'Edge Robusto',
                icon: Icons.ShieldCheck
            },
            DEFAULT: {
                container: 'bg-slate-50 dark:bg-slate-900/50 border-slate-200 dark:border-slate-800 text-slate-600 dark:text-slate-300',
                message: 'Sin evaluación aún',
                icon: Icons.Activity
            }
        };

        // --- UTILIDADES ---
        const parseCustomDate = (dateStr, timeStr) => {
            if (!dateStr || !timeStr) return null;
            const [day, month, year] = dateStr.split('/').map(Number);
            const parts = timeStr.split(' ');
            const timeParts = parts[0].split(':').map(Number);
            let hours = timeParts[0];
            const minutes = timeParts[1];
            const modifier = parts[1] || parts[2];
            if (hours === 12) hours = 0;
            if (modifier && (modifier.toLowerCase().includes('p.m') || modifier.toLowerCase().includes('pm'))) hours += 12;
            return new Date(year, month - 1, day, hours, minutes);
        };
        const parseIsoDateTime = (dateTimeStr) => {
            if (!dateTimeStr) return null;
            const [datePart, timePartRaw] = dateTimeStr.trim().split(' ');
            const [year, month, day] = datePart.split('-').map(Number);
            const tp = (timePartRaw || '').trim();
            const hh = parseInt(tp.slice(0, 2) || '0', 10);
            const mm = parseInt(tp.slice(2, 4) || '0', 10);
            const ss = parseInt(tp.slice(4, 6) || '0', 10);
            return new Date(Date.UTC(year, month - 1, day, hh, mm, ss));
        };

        const parseFlexibleDateTime = (value) => {
            if (!value) return null;
            const raw = String(value).trim();
            if (!raw) return null;

            const direct = new Date(raw);
            if (!isNaN(direct.getTime())) return direct;

            const m = raw.match(/^(\d{4})-(\d{2})-(\d{2})(?:[ T](\d{2}):?(\d{2})(?::?(\d{2}))?)?$/);
            if (m) {
                const year = Number(m[1]);
                const month = Number(m[2]);
                const day = Number(m[3]);
                const hh = Number(m[4] || 0);
                const mm = Number(m[5] || 0);
                const ss = Number(m[6] || 0);
                const d = new Date(Date.UTC(year, month - 1, day, hh, mm, ss));
                if (!isNaN(d.getTime())) return d;
            }

            return parseIsoDateTime(raw);
        };

        const calculateIndicators = (data) => {
            // Cálculos simplificados pero funcionales para la demo
            const period = 14;
            let gains = 0, losses = 0;
            const results = [];
            const sma200 = [];

            // === ADX (Average Directional Index) for Regime Detection ===
            const adxPeriod = 14;
            const adxValues = [];
            let prevPlusDM = 0, prevMinusDM = 0, prevTR = 0, prevDX = 0;

            // Para volatilidad (Cuerpo promedio últimas 5 velas)
            const bodySizes = [];

            // --- ADR (Average Daily Range) ---
            // Estructura para almacenar rangos diarios cerrados
            const dailyRanges = []; // Array de { date: 'YYYY-MM-DD', range: high - low }
            let currentDayKey = null;
            let currentDayOpen = null;
            let currentDayHigh = -Infinity;
            let currentDayLow = Infinity;

            // Pre-procesamiento: Calcular rangos diarios
            const adrData = []; // Almacenará los datos ADR por vela

            const getDayKey = (dt) => {
                if (!dt) return null;
                return `${dt.getFullYear()}-${String(dt.getMonth() + 1).padStart(2, '0')}-${String(dt.getDate()).padStart(2, '0')}`;
            };

            for (let i = 0; i < data.length; i++) {
                const c = data[i];
                const dayKey = getDayKey(c.datetime);

                // SMA
                if (i >= 199) {
                    let sum = 0;
                    for (let j = 0; j < 200; j++) sum += data[i - j].close;
                    sma200.push(sum / 200);
                } else sma200.push(null);

                // Volatilidad (Tamaño cuerpo %)
                const bodySize = Math.abs(c.close - c.open) / c.open;
                bodySizes.push(bodySize);
                let avgBodySize = 0;
                if (i >= 4) {
                    let sumBody = 0;
                    for (let k = 0; k < 5; k++) sumBody += bodySizes[i - k];
                    avgBodySize = sumBody / 5;
                } else {
                    avgBodySize = bodySize; // Fallback inicial
                }

                // --- Lógica ADR: Detectar cambio de día ---
                const isNewDay = (dayKey !== currentDayKey);
                if (isNewDay) {
                    // Si había un día previo, guardar su rango
                    if (currentDayKey !== null && currentDayHigh !== -Infinity && currentDayLow !== Infinity) {
                        dailyRanges.push({
                            date: currentDayKey,
                            range: currentDayHigh - currentDayLow
                        });
                        // Mantener solo los últimos 14 días cerrados
                        if (dailyRanges.length > 14) {
                            dailyRanges.shift();
                        }
                    }
                }

                // --- CALCULAR ADR PARA ESTA VELA (Basado en el estado PREVIO a la vela actual) ---
                let adrValue = null;
                let adrFilledPct = null;
                let currentDayRange = null;
                let adrRoomTop = null;
                let adrRoomBottom = null;

                if (dailyRanges.length >= 1 && (isNewDay || currentDayOpen !== null)) {
                    // Calcular promedio de rangos diarios (excluyendo día actual)
                    const rangesToUse = dailyRanges.slice(-14);
                    if (rangesToUse.length > 0) {
                        const sumRanges = rangesToUse.reduce((acc, dr) => acc + dr.range, 0);
                        adrValue = sumRanges / rangesToUse.length;

                        // Rango del día actual hasta la vela anterior
                        // Si es nuevo día, el rango acumulado es 0
                        currentDayRange = isNewDay ? 0 : (currentDayHigh - currentDayLow);

                        // Porcentaje completado del ADR
                        adrFilledPct = adrValue > 0 ? (currentDayRange / adrValue) * 100 : 0;

                        // Techos y suelos estadísticos (Basados en el Open del día actual)
                        const effectiveDayOpen = isNewDay ? c.open : currentDayOpen;
                        adrRoomTop = effectiveDayOpen + adrValue;
                        adrRoomBottom = effectiveDayOpen - adrValue;
                    }
                }

                // --- ACTUALIZAR MÁXIMOS/MÍNIMOS PARA LA PRÓXIMA VELA ---
                if (isNewDay) {
                    // Iniciar nuevo día
                    currentDayKey = dayKey;
                    currentDayOpen = c.open;
                    currentDayHigh = c.high;
                    currentDayLow = c.low;
                } else {
                    // Actualizar máximos y mínimos del día actual
                    if (c.high > currentDayHigh) currentDayHigh = c.high;
                    if (c.low < currentDayLow) currentDayLow = c.low;
                }

                adrData.push({
                    adrValue,
                    adrFilledPct,
                    currentDayRange,
                    adrRoomTop,
                    adrRoomBottom,
                    dayOpen: currentDayOpen
                });

                // RSI
                if (i === 0) {
                    results.push(null);
                } else {
                    const change = data[i].close - data[i - 1].close;
                    if (change > 0) gains += change; else losses += Math.abs(change);

                    if (i < period) {
                        results.push(null);
                    } else {
                        let avgGain, avgLoss;
                        if (i === period) {
                            avgGain = gains / period;
                            avgLoss = losses / period;
                        } else {
                            const currentGain = change > 0 ? change : 0;
                            const currentLoss = change < 0 ? Math.abs(change) : 0;
                            avgGain = (results[i - 1].avgGain * 13 + currentGain) / 14;
                            avgLoss = (results[i - 1].avgLoss * 13 + currentLoss) / 14;
                        }

                        const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                        const rsi = 100 - (100 / (1 + rs));
                        results.push({ val: rsi, avgGain, avgLoss });
                    }
                }

                // === ADX Calculation ===
                let adx = null;
                if (i >= 1) {
                    const high = data[i].high;
                    const low = data[i].low;
                    const prevHigh = data[i - 1].high;
                    const prevLow = data[i - 1].low;
                    const prevClose = data[i - 1].close;

                    // True Range
                    const tr = Math.max(
                        high - low,
                        Math.abs(high - prevClose),
                        Math.abs(low - prevClose)
                    );

                    // Directional Movement
                    const upMove = high - prevHigh;
                    const downMove = prevLow - low;
                    const plusDM = upMove > downMove && upMove > 0 ? upMove : 0;
                    const minusDM = downMove > upMove && downMove > 0 ? downMove : 0;

                    if (i < adxPeriod) {
                        prevTR += tr;
                        prevPlusDM += plusDM;
                        prevMinusDM += minusDM;
                    } else if (i === adxPeriod) {
                        // First smoothed values
                        prevTR = prevTR;
                        prevPlusDM = prevPlusDM;
                        prevMinusDM = prevMinusDM;
                    } else {
                        // Wilder's smoothing
                        prevTR = prevTR - (prevTR / adxPeriod) + tr;
                        prevPlusDM = prevPlusDM - (prevPlusDM / adxPeriod) + plusDM;
                        prevMinusDM = prevMinusDM - (prevMinusDM / adxPeriod) + minusDM;
                    }

                    if (i >= adxPeriod && prevTR > 0) {
                        const plusDI = (prevPlusDM / prevTR) * 100;
                        const minusDI = (prevMinusDM / prevTR) * 100;
                        const diSum = plusDI + minusDI;
                        const dx = diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0;

                        if (i === adxPeriod) {
                            prevDX = dx;
                            adx = dx;
                        } else {
                            // Smooth ADX with Wilder's method
                            adx = ((prevDX * (adxPeriod - 1)) + dx) / adxPeriod;
                            prevDX = adx;
                        }
                    }
                }
                adxValues.push(adx);
            }

            return data.map((d, i) => ({
                ...d,
                rsi: (results[i] && results[i].val) || null,
                sma200: sma200[i],
                hour: d.datetime ? d.datetime.getHours() : 0,
                hourLocal: d.datetime ? d.datetime.getHours() : null,
                hourUtc: d.datetime ? d.datetime.getUTCHours() : null,
                bodySizePct: (Math.abs(d.close - d.open) / d.open) * 100,
                // --- Campos ADR ---
                adrValue: adrData[i] ? adrData[i].adrValue : null,
                adrFilledPct: adrData[i] ? adrData[i].adrFilledPct : null,
                currentDayRange: adrData[i] ? adrData[i].currentDayRange : null,
                adrRoomTop: adrData[i] ? adrData[i].adrRoomTop : null,
                adrRoomBottom: adrData[i] ? adrData[i].adrRoomBottom : null,
                dayOpen: adrData[i] ? adrData[i].dayOpen : null,
                // --- ADX (Regime Detection) ---
                adx: adxValues[i] || null
            }));
        };

        // --- COMPONENTE PRINCIPAL ---
        const App = () => {
            // DATA & CONFIG
            const [activeTab, setActiveTab] = useState('LAB'); // 'LAB' (Laboratorio) | 'MONITOR' (Monitor Activo)
            const [csvData, setCsvData] = useState([]);
            const [selectedCandleIndex, setSelectedCandleIndex] = useState(-1);
            const [tfMinutes, setTfMinutes] = useState(null);
            const [isDragging, setIsDragging] = useState(false);
            const [fileName, setFileName] = useState('');
            const [fileError, setFileError] = useState(null);

            const [htfData, setHtfData] = useState([]);
            const [htfTfMinutes, setHtfTfMinutes] = useState(null);
            const [htfFileName, setHtfFileName] = useState('');
            const [htfError, setHtfError] = useState(null);

            const [ltfData, setLtfData] = useState([]);
            const [ltfTfMinutes, setLtfTfMinutes] = useState(null);
            const [ltfFileName, setLtfFileName] = useState('');
            const [ltfError, setLtfError] = useState(null);

            const [isAutoLoadOpen, setIsAutoLoadOpen] = useState(false);
            const [autoMarket, setAutoMarket] = useState('crypto');
            const [autoSymbol, setAutoSymbol] = useState('BTCUSDT');
            const [autoEntryTf, setAutoEntryTf] = useState('1h');
            const [autoStartDate, setAutoStartDate] = useState('');
            const [autoEndDate, setAutoEndDate] = useState('');
            const [autoLoadError, setAutoLoadError] = useState(null);
            const [autoLoadPhase, setAutoLoadPhase] = useState('idle');
            const [autoHasTwelveApiKey, setAutoHasTwelveApiKey] = useState(false);
            const [autoProgress, setAutoProgress] = useState({
                main: { status: 'idle', candles: 0, expected: 0, calls: 0 },
                htf: { status: 'idle', candles: 0, expected: 0, calls: 0 },
                ltf: { status: 'idle', candles: 0, expected: 0, calls: 0 }
            });
            const autoAbortRef = useRef(null);
            const twelveRateRef = useRef({ windowStart: 0, count: 0, queue: [], timer: null });

            // PERSISTENCIA DE SESIÓN (Refs y Keys)
            const SESSION_KEY = 'fti_terminal_session';
            const SIMS_KEY = 'fti_saved_simulations';
            const isRestoringRef = useRef(true);
            const isClearingRef = useRef(false);

            const refreshTwelveApiKeyStatus = () => {
                try {
                    setAutoHasTwelveApiKey(!!localStorage.getItem('fti_twelve_api_key'));
                } catch (e) {
                    setAutoHasTwelveApiKey(false);
                }
            };

            useEffect(() => {
                if (!isAutoLoadOpen) return;
                refreshTwelveApiKeyStatus();
                const onStorage = (e) => {
                    if (e && e.key === 'fti_twelve_api_key') refreshTwelveApiKeyStatus();
                };
                window.addEventListener('storage', onStorage);
                return () => window.removeEventListener('storage', onStorage);
            }, [isAutoLoadOpen]);

            useEffect(() => {
                if (isRestoringRef.current) return;
                if (autoMarket === 'crypto') {
                    if (!POPULAR_PAIRS.includes(autoSymbol)) setAutoSymbol(POPULAR_PAIRS[0] || 'BTCUSDT');
                    return;
                }
                if (!FOREX_PAIRS.includes(autoSymbol)) setAutoSymbol(FOREX_PAIRS[0] || 'XAU/USD');
            }, [autoMarket]);

            // PARAMETROS DE TRADE
            const [tradeType, setTradeType] = useState('LONG');
            const [entryPrice, setEntryPrice] = useState(0);
            const [stopLoss, setStopLoss] = useState('');
            const [takeProfit, setTakeProfit] = useState('');
            const [spread, setSpread] = useState('0');

            const [useMacroMode, setUseMacroMode] = useState(false);

            // FILTROS
            const [useRsiFilter, setUseRsiFilter] = useState(false);
            const [targetRsi, setTargetRsi] = useState(50);
            const [rsiTolerance, setRsiTolerance] = useState(5);
            const [useTrendFilter, setUseTrendFilter] = useState(false);
            const [trendCondition, setTrendCondition] = useState('ABOVE');
            const [useTimeFilter, setUseTimeFilter] = useState(false);
            const [timeMode, setTimeMode] = useState('LOCAL');
            const [useVolFilter, setUseVolFilter] = useState(false);
            const [useCooldownFilter, setUseCooldownFilter] = useState(true);
            const [useAdrFilter, setUseAdrFilter] = useState(false);
            const [useVolumeFilter, setUseVolumeFilter] = useState(false);
            const [volumeTolerance, setVolumeTolerance] = useState(50);
            const [useBuyPressureFilter, setUseBuyPressureFilter] = useState(false);
            const [bpTolerance, setBpTolerance] = useState(5);
            const [useDeltaSignFilter, setUseDeltaSignFilter] = useState(false);

            const [useHtfFilter, setUseHtfFilter] = useState(false);
            const [htfMode, setHtfMode] = useState('DISCARD');
            const [requireHtf, setRequireHtf] = useState(true);

            const [useLtfIntra, setUseLtfIntra] = useState(false);
            const [ltfMaxCandles, setLtfMaxCandles] = useState(20000);

            // === WALK-FORWARD ANALYSIS ===
            const [useWalkForward, setUseWalkForward] = useState(false);
            const [walkForwardSplit, setWalkForwardSplit] = useState(70); // 70% in-sample, 30% out-of-sample
            const [walkForwardResult, setWalkForwardResult] = useState(null); // { inSample: {...}, outOfSample: {...}, degradation: number }

            // === MONTE CARLO SIMULATION ===
            const [monteCarloSimulations, setMonteCarloSimulations] = useState(1000);
            const [isRunningMonteCarlo, setIsRunningMonteCarlo] = useState(false);
            const [monteCarloResult, setMonteCarloResult] = useState(null);
            // Result: { worstDrawdown, avgDrawdown, ruinProbability, percentiles: {p5,p25,p50,p75,p95}, equityCurves: [] }

            // === MARKET REGIME FILTER ===
            const [useRegimeFilter, setUseRegimeFilter] = useState(false);
            const [adxThreshold, setAdxThreshold] = useState(25); // ADX > 25 = trending

            // RESULTADOS & ESTADOS ADICIONALES
            const [simResult, setSimResult] = useState(null);
            const [optimizationResults, setOptimizationResults] = useState(null);
            const [isOptimizing, setIsOptimizing] = useState(false);
            const [isAutoDetecting, setIsAutoDetecting] = useState(false);
            const [copyAllStatus, setCopyAllStatus] = useState('idle');
            const [currentPrice, setCurrentPrice] = useState('');
            const [candlesSinceEntry, setCandlesSinceEntry] = useState(0);
            const [liveTradeStatus, setLiveTradeStatus] = useState(null); // null | { status: 'WIN'|'LOSS'|'ACTIVE', exitPrice, exitDate }
            const [liveHistory, setLiveHistory] = useState([]);
            const [isDurationModalOpen, setIsDurationModalOpen] = useState(false);

            // --- PERSISTENCIA DE SESIÓN ---
            const [savedSims, setSavedSims] = useState([]);

            // Función para guardar el estado actual en localStorage
            const saveSession = useCallback(() => {
                if (isRestoringRef.current || isClearingRef.current) return;
                const session = {
                    lastUpdate: Date.now(),
                    activeTab,
                    selectedCandleIndex,
                    tfMinutes,
                    fileName,
                    tradeType,
                    entryPrice,
                    stopLoss,
                    takeProfit,
                    spread,
                    useMacroMode,
                    useRsiFilter,
                    targetRsi,
                    rsiTolerance,
                    useTrendFilter,
                    trendCondition,
                    useTimeFilter,
                    timeMode,
                    useVolFilter,
                    useCooldownFilter,
                    useAdrFilter,
                    useVolumeFilter,
                    volumeTolerance,
                    useBuyPressureFilter,
                    bpTolerance,
                    useDeltaSignFilter,
                    useHtfFilter,
                    htfMode,
                    requireHtf,
                    useLtfIntra,
                    ltfMaxCandles,
                    simResult,
                    optimizationResults,
                    csvData,
                    htfData,
                    ltfData,
                    htfTfMinutes,
                    htfFileName,
                    ltfTfMinutes,
                    ltfFileName,
                    autoMarket,
                    autoSymbol,
                    autoEntryTf,
                    autoStartDate,
                    autoEndDate
                };

                try {
                    localStorage.setItem(SESSION_KEY, JSON.stringify(session));
                } catch (e) {
                    console.warn('Espacio insuficiente en localStorage. Guardando sesión sin datasets pesados.');
                    const lightSession = { ...session, csvData: [], htfData: [], ltfData: [] };
                    try {
                        localStorage.setItem(SESSION_KEY, JSON.stringify(lightSession));
                    } catch (e2) {
                        console.error('Error al guardar sesión ligera:', e2);
                    }
                }
            }, [
                activeTab, selectedCandleIndex, tfMinutes, fileName,
                tradeType, entryPrice, stopLoss, takeProfit, spread, useMacroMode,
                useRsiFilter, targetRsi, rsiTolerance, useTrendFilter, trendCondition,
                useTimeFilter, timeMode, useVolFilter, useCooldownFilter, useAdrFilter, useVolumeFilter,
                volumeTolerance, useBuyPressureFilter, bpTolerance, useDeltaSignFilter,
                useHtfFilter, htfMode, requireHtf, useLtfIntra, ltfMaxCandles,
                simResult, optimizationResults, csvData, htfData, ltfData,
                htfTfMinutes, htfFileName, ltfTfMinutes, ltfFileName,
                autoMarket, autoSymbol, autoEntryTf, autoStartDate, autoEndDate
            ]);

            // Efecto para cargar la sesión al iniciar
            useEffect(() => {
                const saved = localStorage.getItem(SESSION_KEY);
                if (saved) {
                    try {
                        const session = JSON.parse(saved, (key, value) => {
                            if ((key === 'datetime' || key === 'dateIso') && typeof value === 'string') {
                                const d = new Date(value);
                                return isNaN(d.getTime()) ? value : d;
                            }
                            return value;
                        });

                        // EXPIRACIÓN: Si han pasado más de 5 minutos, ignorar y borrar
                        const FIVE_MINUTES_MS = 5 * 60 * 1000;
                        if (session.lastUpdate && (Date.now() - session.lastUpdate > FIVE_MINUTES_MS)) {
                            console.log('Sesión activa expirada (>5 min). Iniciando nueva sesión.');
                            localStorage.removeItem(SESSION_KEY);
                            isRestoringRef.current = false;
                            return;
                        }

                        // Restaurar estados uno por uno
                        if (session.activeTab) setActiveTab(session.activeTab);
                        if (session.csvData) setCsvData(session.csvData);
                        if (session.selectedCandleIndex !== undefined) setSelectedCandleIndex(session.selectedCandleIndex);
                        if (session.tfMinutes) setTfMinutes(session.tfMinutes);
                        if (session.fileName) setFileName(session.fileName);
                        if (session.tradeType) setTradeType(session.tradeType);
                        if (session.entryPrice) setEntryPrice(session.entryPrice);
                        if (session.stopLoss) setStopLoss(session.stopLoss);
                        if (session.takeProfit) setTakeProfit(session.takeProfit);
                        if (session.spread) setSpread(session.spread);
                        if (session.useMacroMode !== undefined) setUseMacroMode(session.useMacroMode);
                        if (session.useRsiFilter !== undefined) setUseRsiFilter(session.useRsiFilter);
                        if (session.targetRsi) setTargetRsi(session.targetRsi);
                        if (session.rsiTolerance) setRsiTolerance(session.rsiTolerance);
                        if (session.useTrendFilter !== undefined) setUseTrendFilter(session.useTrendFilter);
                        if (session.trendCondition) setTrendCondition(session.trendCondition);
                        if (session.useTimeFilter !== undefined) setUseTimeFilter(session.useTimeFilter);
                        if (session.timeMode) setTimeMode(session.timeMode);
                        if (session.useVolFilter !== undefined) setUseVolFilter(session.useVolFilter);
                        if (session.useCooldownFilter !== undefined) setUseCooldownFilter(session.useCooldownFilter);
                        if (session.useAdrFilter !== undefined) setUseAdrFilter(session.useAdrFilter);
                        if (session.useVolumeFilter !== undefined) setUseVolumeFilter(session.useVolumeFilter);
                        if (session.volumeTolerance) setVolumeTolerance(session.volumeTolerance);
                        if (session.useBuyPressureFilter !== undefined) setUseBuyPressureFilter(session.useBuyPressureFilter);
                        if (session.bpTolerance) setBpTolerance(session.bpTolerance);
                        if (session.useDeltaSignFilter !== undefined) setUseDeltaSignFilter(session.useDeltaSignFilter);
                        if (session.useHtfFilter !== undefined) setUseHtfFilter(session.useHtfFilter);
                        if (session.htfMode) setHtfMode(session.htfMode);
                        if (session.requireHtf !== undefined) setRequireHtf(session.requireHtf);
                        if (session.useLtfIntra !== undefined) setUseLtfIntra(session.useLtfIntra);
                        if (session.ltfMaxCandles) setLtfMaxCandles(session.ltfMaxCandles);
                        if (session.simResult) setSimResult(session.simResult);
                        if (session.optimizationResults) setOptimizationResults(session.optimizationResults);
                        if (session.htfData) setHtfData(session.htfData);
                        if (session.htfTfMinutes) setHtfTfMinutes(session.htfTfMinutes);
                        if (session.htfFileName) setHtfFileName(session.htfFileName);
                        if (session.ltfData) setLtfData(session.ltfData);
                        if (session.ltfTfMinutes) setLtfTfMinutes(session.ltfTfMinutes);
                        if (session.ltfFileName) setLtfFileName(session.ltfFileName);
                        if (session.autoMarket) setAutoMarket(session.autoMarket);
                        if (session.autoSymbol) setAutoSymbol(session.autoSymbol);
                        if (session.autoEntryTf) setAutoEntryTf(session.autoEntryTf);
                        if (session.autoStartDate) setAutoStartDate(session.autoStartDate);
                        if (session.autoEndDate) setAutoEndDate(session.autoEndDate);

                    } catch (e) {
                        console.error('Error al restaurar la sesión:', e);
                    }
                }
                isRestoringRef.current = false;
            }, []);

            // Efecto para disparar el guardado cuando algo cambia (debounced)
            useEffect(() => {
                const timer = setTimeout(saveSession, 1500);
                return () => clearTimeout(timer);
            }, [saveSession]);

            const refreshSavedSims = () => {
                try {
                    const arr = JSON.parse(localStorage.getItem(SIMS_KEY) || '[]');
                    setSavedSims(Array.isArray(arr) ? arr : []);
                } catch (e) {
                    setSavedSims([]);
                }
            };
            const editSavedSimName = (id) => {
                const nn = window.prompt('Nuevo nombre para la simulación');
                if (!nn) return;
                const next = savedSims.map(s => s.id === id ? { ...s, name: nn } : s);
                try {
                    localStorage.setItem(SIMS_KEY, JSON.stringify(next));
                } catch (e) {
                    alert('No se pudo guardar el cambio de nombre. Almacenamiento lleno o bloqueado.');
                    return;
                }
                setSavedSims(next);
            };
            const deleteSavedSim = (id) => {
                if (!window.confirm('¿Eliminar esta simulación?')) return;
                const next = savedSims.filter(s => s.id !== id);
                try {
                    localStorage.setItem(SIMS_KEY, JSON.stringify(next));
                } catch (e) {
                    alert('No se pudo guardar la eliminación. Almacenamiento lleno o bloqueado.');
                    return;
                }
                setSavedSims(next);
            };

            const handleClearCurrentSession = () => {
                if (!window.confirm('¿Deseas limpiar la sesión actual y comenzar de cero? (Esto borrará los parámetros y resultados no guardados)')) return;
                isClearingRef.current = true;
                localStorage.removeItem(SESSION_KEY);
                window.location.reload();
            };

            const handleSyncLivePrice = async () => {
                if (selectedCandleIndex < 0 || !csvData[selectedCandleIndex]) {
                    alert('Selecciona primero una vela de entrada en la pestaña Laboratorio.');
                    return;
                }

                let symbol = autoSymbol;
                if (!symbol) {
                    symbol = prompt("No se detectó un símbolo automático. Ingresa el par (ej. BTCUSDT o EUR/USD):", "BTCUSDT");
                    if (!symbol) return;
                    setAutoSymbol(symbol);
                }

                let tf = tfMinutes;
                if (!tf) {
                    const tfMap = { '1m': 1, '5m': 5, '15m': 15, '30m': 30, '1h': 60, '4h': 240, '1d': 1440 };
                    tf = tfMap[autoEntryTf] || 60;
                }

                // Resetear estado previo
                setLiveTradeStatus(null);
                setLiveHistory([]);

                try {
                    const btn = document.getElementById('btn-sync-live');
                    if (btn) btn.innerHTML = '<span class="animate-spin inline-block">↻</span> ...';

                    let price = null;
                    const isForex = autoMarket === 'forex' || symbol.includes('/') || (symbol.length === 6 && !symbol.includes('USDT'));

                    // Datos para verificación histórica
                    const entryCandle = csvData[selectedCandleIndex];
                    let entryDate = new Date(entryCandle.datetime);
                    if (isNaN(entryDate.getTime()) && entryCandle.dateIso) entryDate = new Date(entryCandle.dateIso);

                    const slVal = parseFloat(stopLoss);
                    const tpVal = parseFloat(takeProfit);
                    const hasLevels = !isNaN(slVal) && !isNaN(tpVal);

                    // Función auxiliar para verificar TP/SL en una vela
                    const checkCandle = (high, low, time) => {
                        if (!hasLevels) return null;
                        if (tradeType === 'LONG') {
                            if (low <= slVal) return { status: 'LOSS', price: slVal, date: time };
                            if (high >= tpVal) return { status: 'WIN', price: tpVal, date: time };
                        } else {
                            if (high >= slVal) return { status: 'LOSS', price: slVal, date: time };
                            if (low <= tpVal) return { status: 'WIN', price: tpVal, date: time };
                        }
                        return null;
                    };

                    let tradeOutcome = null;

                    if (isForex) {
                        // --- TWELVE DATA (FOREX) ---
                        const apiKey = localStorage.getItem('fti_twelve_api_key');
                        if (!apiKey) throw new Error('Se requiere API Key de TwelveData para sincronizar Forex.');

                        let tdSymbol = symbol;
                        if (!tdSymbol.includes('/') && tdSymbol.length === 6) {
                            tdSymbol = tdSymbol.slice(0, 3) + '/' + tdSymbol.slice(3);
                        }

                        // 1. Obtener precio actual
                        const resPrice = await fetch(`https://api.twelvedata.com/price?symbol=${tdSymbol}&apikey=${apiKey}`);
                        if (!resPrice.ok) throw new Error('Error API TwelveData Price');
                        const dataPrice = await resPrice.json();
                        if (dataPrice.code && dataPrice.code !== 200) throw new Error(dataPrice.message || 'Error TwelveData');
                        price = parseFloat(dataPrice.price);

                        // 2. Verificación Histórica (Solo si hay niveles definidos)
                        if (hasLevels && !isNaN(entryDate.getTime())) {
                            // Pedimos velas de 4h o 1d para economizar API, o 1h si es reciente
                            // TwelveData TimeSeries
                            const interval = '1h'; // Balance entre precisión y economía
                            // Construir fecha start para API (YYYY-MM-DD)
                            const startDateStr = entryDate.toISOString().split('T')[0];

                            const resHist = await fetch(`https://api.twelvedata.com/time_series?symbol=${tdSymbol}&interval=${interval}&start_date=${startDateStr}&apikey=${apiKey}&outputsize=500&order=ASC`);
                            if (resHist.ok) {
                                const dataHist = await resHist.json();
                                if (dataHist.values && Array.isArray(dataHist.values)) {
                                    // TwelveData devuelve orden DESC por defecto si no se especifica, pero pedimos ASC
                                    // Asegurar orden cronológico
                                    const candles = dataHist.values.sort((a, b) => new Date(a.datetime) - new Date(b.datetime));
                                    const series = candles.map((c) => {
                                        const dt = new Date(c.datetime);
                                        return {
                                            datetime: dt,
                                            open: parseFloat(c.open),
                                            high: parseFloat(c.high),
                                            low: parseFloat(c.low),
                                            close: parseFloat(c.close)
                                        };
                                    }).filter(x =>
                                        x.datetime instanceof Date &&
                                        !isNaN(x.datetime.getTime()) &&
                                        [x.open, x.high, x.low, x.close].every(v => isFinite(v))
                                    );
                                    setLiveHistory(series);

                                    for (const c of candles) {
                                        const cTime = new Date(c.datetime);
                                        if (cTime < entryDate) continue; // Ignorar velas previas a entrada exacta

                                        const outcome = checkCandle(parseFloat(c.high), parseFloat(c.low), cTime);
                                        if (outcome) {
                                            tradeOutcome = outcome;
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                    } else {
                        // --- BINANCE (CRYPTO) ---
                        const binanceSymbol = symbol.replace(/[^a-zA-Z0-9]/g, '').toUpperCase();

                        // 1. Precio Actual
                        const resPrice = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${binanceSymbol}`);
                        if (!resPrice.ok) throw new Error('Error API Binance');
                        const dataPrice = await resPrice.json();
                        price = parseFloat(dataPrice.price);

                        // 2. Verificación Histórica
                        if (hasLevels && !isNaN(entryDate.getTime())) {
                            const interval = '1h';
                            const startTime = entryDate.getTime();
                            // Binance klines limit 1000
                            const resKlines = await fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=${interval}&startTime=${startTime}&limit=1000`);

                            if (resKlines.ok) {
                                const klines = await resKlines.json();
                                const series = (Array.isArray(klines) ? klines : []).map((k) => ({
                                    datetime: new Date(k[0]),
                                    open: parseFloat(k[1]),
                                    high: parseFloat(k[2]),
                                    low: parseFloat(k[3]),
                                    close: parseFloat(k[4])
                                })).filter(x =>
                                    x.datetime instanceof Date &&
                                    !isNaN(x.datetime.getTime()) &&
                                    [x.open, x.high, x.low, x.close].every(v => isFinite(v))
                                );
                                setLiveHistory(series);
                                // klines: [openTime, open, high, low, close, ...]
                                for (const k of klines) {
                                    const cTime = new Date(k[0]);
                                    const outcome = checkCandle(parseFloat(k[2]), parseFloat(k[3]), cTime);
                                    if (outcome) {
                                        tradeOutcome = outcome;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    if (isNaN(price)) throw new Error('Precio inválido recibido');
                    setCurrentPrice(price);

                    // Verificar con precio actual si no se encontró en histórico (por si acaso la vela actual no cerró o gap)
                    if (!tradeOutcome && hasLevels) {
                        if (tradeType === 'LONG') {
                            if (price <= slVal) tradeOutcome = { status: 'LOSS', price: price, date: new Date() };
                            else if (price >= tpVal) tradeOutcome = { status: 'WIN', price: price, date: new Date() };
                        } else {
                            if (price >= slVal) tradeOutcome = { status: 'LOSS', price: price, date: new Date() };
                            else if (price <= tpVal) tradeOutcome = { status: 'WIN', price: price, date: new Date() };
                        }
                    }

                    // Establecer estado final
                    if (tradeOutcome) {
                        setLiveTradeStatus(tradeOutcome);
                    } else {
                        setLiveTradeStatus({ status: 'ACTIVE' });
                    }

                    // Calculo de velas
                    if (!isNaN(entryDate.getTime())) {
                        const now = tradeOutcome ? tradeOutcome.date : new Date();
                        const diffMs = now - entryDate;
                        const diffMins = diffMs / (1000 * 60);
                        const candles = Math.floor(diffMins / tf);
                        setCandlesSinceEntry(Math.max(0, candles));
                    }

                } catch (e) {
                    console.error(e);
                    alert(`No se pudo sincronizar precio para ${symbol}.\n\nDetalle: ${e.message}`);
                    setLiveTradeStatus(null);
                } finally {
                    const btn = document.getElementById('btn-sync-live');
                    if (btn) btn.innerHTML = '⚡ Sincronizar Ahora';
                }
            };

            const handleSaveSimulation = () => {
                if (!simResult) return;
                const name = window.prompt('Nombre para esta simulación');
                if (!name) return;
                const target = csvData[selectedCandleIndex];
                const params = {
                    analysis: { useMacroMode, maxDurationLimit: useMacroMode ? 5000 : 500 },
                    tradeType,
                    entryPrice,
                    stopLoss,
                    takeProfit,
                    spread,
                    rsi: { useRsiFilter, targetRsi, rsiTolerance },
                    trend: { useTrendFilter, trendCondition },
                    time: { useTimeFilter, timeMode },
                    volBody: { useVolFilter },
                    cooldown: { useCooldownFilter },
                    mtf: {
                        useHtfFilter,
                        htfMode,
                        requireHtf,
                        useLtfIntra
                    },
                    extended: { useVolumeFilter, volumeTolerance, useBuyPressureFilter, bpTolerance, useDeltaSignFilter }
                };
                const snapshot = target ? {
                    datetime: target.datetime && target.datetime.toISOString ? target.datetime.toISOString() : null,
                    open: target.open,
                    high: target.high,
                    low: target.low,
                    close: target.close,
                    rsi: target.rsi,
                    sma200: target.sma200,
                    bodySizePct: target.bodySizePct,
                    hour: target.hour,
                    volume: target.volume,
                    delta: target.delta,
                    buyPressurePct: target.buyPressurePct
                } : null;
                const item = {
                    id: Date.now().toString(),
                    name,
                    createdAt: new Date().toISOString(),
                    metrics: { ...simResult },
                    walkForwardMetrics: walkForwardResult ? { ...walkForwardResult } : null,
                    params,
                    targetCandle: snapshot,
                    dataset: { length: csvData.length, hasExtended, htfLength: htfData.length, ltfLength: ltfData.length }
                };
                try {
                    const arr = JSON.parse(localStorage.getItem(SIMS_KEY) || '[]');
                    const next = Array.isArray(arr) ? arr.concat([item]) : [item];
                    localStorage.setItem(SIMS_KEY, JSON.stringify(next));
                    setSavedSims(next);
                    alert('Simulación guardada');
                } catch (e) {
                    console.error('Error guardando simulación:', e);
                    try {
                        // Intento de fallback: guardar solo el último ítem si falla por espacio
                        // PERO con advertencia y sin sobreescribir todo a lo loco si no es necesario
                        alert('Error al guardar: Posible espacio lleno. Se intentará guardar solo esta simulación.');
                        localStorage.setItem(SIMS_KEY, JSON.stringify([item]));
                        setSavedSims([item]);
                    } catch (e2) {
                        alert('No se pudo guardar la simulación. El almacenamiento local está lleno o bloqueado.');
                    }
                }
            };

            const takeScreenshot = async () => {
                const btn = document.activeElement;
                const prevContent = btn ? btn.innerHTML : '';
                if (btn && btn.tagName === 'BUTTON') {
                    btn.disabled = true;
                    btn.innerHTML = '<span class="animate-pulse">...</span>';
                }

                try {
                    if (document.fonts && document.fonts.ready) {
                        await document.fonts.ready;
                    }
                    const element = document.body;

                    const canvas = await html2canvas(element, {
                        scale: 2,
                        useCORS: true,
                        allowTaint: true,

                        backgroundColor: document.documentElement.classList.contains('dark') ? '#0f172a' : '#f8fafc',

                        windowWidth: 1600,
                        windowHeight: document.documentElement.scrollHeight,

                        onclone: (clonedDoc) => {
                            const clonedRoot = clonedDoc.getElementById('root');
                            if (clonedRoot) {
                                clonedRoot.style.backgroundColor = document.documentElement.classList.contains('dark') ? '#0f172a' : '#f8fafc';
                                clonedRoot.style.minHeight = '100vh';

                                const animated = clonedRoot.querySelectorAll('.animate-fade-in');
                                animated.forEach(el => {
                                    el.style.animation = 'none';
                                    el.style.opacity = '1';
                                    el.style.transform = 'none';
                                    el.style.transition = 'none';
                                });

                                const wrapper = clonedRoot.querySelector('.max-w-6xl');
                                if (wrapper) {
                                    wrapper.style.margin = '0 auto';
                                    wrapper.style.width = '100%';
                                    wrapper.style.maxWidth = '1400px';
                                    wrapper.style.overflow = 'visible';
                                    wrapper.style.transform = 'none';
                                }

                                const scoreEls = clonedRoot.querySelectorAll('.screenshot-safe-score');
                                scoreEls.forEach(el => {
                                    el.style.lineHeight = '1.2';
                                    el.style.marginBottom = '16px';
                                    el.style.position = 'relative';
                                    el.style.zIndex = '1';
                                });
                                const probBadges = clonedRoot.querySelectorAll('.prob-summary');
                                probBadges.forEach(el => {
                                    el.style.marginTop = '12px';
                                    el.style.position = 'relative';
                                    el.style.zIndex = '0';
                                });
                                const numInputs = clonedRoot.querySelectorAll('input[type="number"]');
                                numInputs.forEach(inp => {
                                    inp.style.height = '45px';
                                    inp.style.paddingTop = '8px';
                                    inp.style.paddingBottom = '8px';
                                    inp.style.boxSizing = 'border-box';
                                    inp.style.display = 'block';
                                    inp.style.overflow = 'visible';
                                    inp.style.appearance = 'none';
                                    inp.style.webkitAppearance = 'none';
                                    inp.style.lineHeight = '24px';
                                });
                            }
                        },
                        ignoreElements: (el) => el.classList.contains('no-screenshot')
                    });

                    const link = document.createElement('a');
                    link.download = `SmartTrading_${new Date().toISOString().slice(0, 19).replace(/[:]/g, '-')}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                } catch (err) {
                    console.error('Error al capturar pantalla:', err);
                    alert('Error generando la imagen. Intente en pantalla completa.');
                } finally {
                    if (btn && btn.tagName === 'BUTTON') {
                        btn.innerHTML = prevContent;
                        btn.disabled = false;
                    }
                }
            };

            const stringifyForExport = (value) => {
                const seen = new WeakSet();
                return JSON.stringify(value, (k, v) => {
                    if (v instanceof Date) return v.toISOString();
                    if (typeof v === 'object' && v !== null) {
                        if (seen.has(v)) return '[Circular]';
                        seen.add(v);
                    }
                    return v;
                }, 2);
            };

            const getExportTextFromElement = (el) => {
                if (!el) return '';
                const clone = el.cloneNode(true);
                const excluded = clone.querySelectorAll('[data-export-exclude="true"]');
                excluded.forEach((n) => n.remove());

                const controls = clone.querySelectorAll('input, select, textarea');
                controls.forEach((node) => {
                    const tag = (node.tagName || '').toLowerCase();
                    const span = document.createElement('span');
                    span.style.whiteSpace = 'pre-wrap';
                    span.style.wordBreak = 'break-word';

                    if (tag === 'select') {
                        const sel = node;
                        const opt = sel.options && sel.selectedIndex >= 0 ? sel.options[sel.selectedIndex] : null;
                        const text = opt ? (opt.textContent || opt.value || '') : (sel.value || '');
                        span.textContent = text ? ` ${text} ` : '';
                        sel.replaceWith(span);
                        return;
                    }

                    if (tag === 'textarea') {
                        const ta = node;
                        const text = ta.value || ta.textContent || '';
                        span.textContent = text ? ` ${text} ` : '';
                        ta.replaceWith(span);
                        return;
                    }

                    const inp = node;
                    const type = (inp.getAttribute('type') || '').toLowerCase();

                    if (type === 'file') {
                        inp.remove();
                        return;
                    }

                    if (type === 'checkbox' || type === 'radio') {
                        span.textContent = inp.checked ? ' Sí ' : ' No ';
                        inp.replaceWith(span);
                        return;
                    }

                    const v = (inp.value != null ? String(inp.value) : '').trim();
                    const p = (inp.getAttribute('placeholder') || '').trim();
                    const text = v || p;
                    span.textContent = text ? ` ${text} ` : '';
                    inp.replaceWith(span);
                });

                const raw = (clone.innerText || '').replace(/\r\n/g, '\n');
                const lines = raw.split('\n').map(l => l.trim()).filter(Boolean);
                const filtered = lines.filter((l) => l !== 'EJECUTAR ANÁLISIS' && l !== 'COPIAR TODO' && l !== 'Copiar todo' && l !== 'Copiado' && l !== 'Error');
                return filtered.join('\n');
            };

            const writeTextToClipboard = async (text) => {
                if (!text) return false;
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(text);
                    return true;
                }
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.setAttribute('readonly', '');
                ta.style.position = 'fixed';
                ta.style.top = '0';
                ta.style.left = '0';
                ta.style.width = '1px';
                ta.style.height = '1px';
                ta.style.opacity = '0';
                document.body.appendChild(ta);
                ta.select();
                ta.setSelectionRange(0, ta.value.length);
                const ok = document.execCommand('copy');
                document.body.removeChild(ta);
                return ok;
            };

            const handleCopyAll = async () => {
                if (!simResult || simResult.error) return;

                setCopyAllStatus('copying');
                const now = new Date();
                const target = csvData[selectedCandleIndex];

                const snapshot = target ? {
                    index: selectedCandleIndex,
                    datetime: target.datetime && target.datetime.toISOString ? target.datetime.toISOString() : null,
                    open: target.open,
                    high: target.high,
                    low: target.low,
                    close: target.close,
                    rsi: target.rsi,
                    sma200: target.sma200,
                    bodySizePct: target.bodySizePct,
                    hourLocal: target.hourLocal,
                    hourUtc: target.hourUtc,
                    volume: target.volume,
                    delta: target.delta,
                    buyPressurePct: target.buyPressurePct
                } : null;

                const params = {
                    analysis: { useMacroMode, maxDurationLimit: useMacroMode ? 5000 : 500 },
                    tradeType,
                    entryPrice,
                    stopLoss,
                    takeProfit,
                    spread,
                    rsi: { useRsiFilter, targetRsi, rsiTolerance },
                    trend: { useTrendFilter, trendCondition },
                    time: { useTimeFilter, timeMode },
                    volBody: { useVolFilter },
                    cooldown: { useCooldownFilter },
                    mtf: {
                        useHtfFilter,
                        htfMode,
                        requireHtf,
                        htfFileName,
                        htfTfMinutes,
                        htfCandles: htfData.length,
                        useLtfIntra,
                        ltfFileName,
                        ltfTfMinutes,
                        ltfMaxCandles,
                        ltfCandles: ltfData.length
                    },
                    extended: { useVolumeFilter, volumeTolerance, useBuyPressureFilter, bpTolerance, useDeltaSignFilter },
                    monitor: { currentPrice, candlesSinceEntry }
                };

                const exportObj = {
                    exportedAt: now.toISOString(),
                    dataset: { fileName, candles: csvData.length, tfMinutes, hasExtended },
                    candle: snapshot,
                    params,
                    result: simResult,
                    walkForwardResult, // Añadir datos de validación Walk-Forward
                    optimizationResults: optimizationResults ? optimizationResults.map((x) => ({
                        isRobust: x.isRobust,
                        stats: x.stats,
                        config: x.config
                    })) : null
                };

                const configEl = document.getElementById('analysis-config');
                const resultsEl = document.getElementById('analysis-results');
                const configText = getExportTextFromElement(configEl);
                const resultsText = getExportTextFromElement(resultsEl);
                const output = [
                    `FTI · Snapshot`,
                    `Exportado: ${now.toLocaleString('es-ES')}`,
                    '',
                    '=== CONFIGURACIÓN Y FILTROS (UI) ===',
                    configText || '—',
                    '',
                    '=== RESULTADOS (UI) ===',
                    resultsText || '—',
                    '',
                    '=== DATOS (RAW) ===',
                    stringifyForExport(exportObj)
                ].join('\n');

                try {
                    const ok = await writeTextToClipboard(output);
                    setCopyAllStatus(ok ? 'success' : 'error');
                } catch (e) {
                    setCopyAllStatus('error');
                } finally {
                    window.setTimeout(() => setCopyAllStatus('idle'), 2000);
                }
            };

            // --- CARGA DE DATOS ---
            const lowerBound = (arr, x) => {
                let lo = 0;
                let hi = arr.length;
                while (lo < hi) {
                    const mid = (lo + hi) >> 1;
                    if (arr[mid] < x) lo = mid + 1;
                    else hi = mid;
                }
                return lo;
            };

            const inferTfMinutesFromSeries = (series, nameHint) => {
                try {
                    const diffs = [];
                    for (let i = 1; i < series.length; i++) {
                        const d = Math.round((series[i].datetime - series[i - 1].datetime) / 60000);
                        if (d > 0 && d <= 10080) diffs.push(d);
                    }
                    const freq = {};
                    diffs.forEach(d => { freq[d] = (freq[d] || 0) + 1; });
                    const mode = (Object.entries(freq).sort((a, b) => b[1] - a[1])[0] || [])[0];
                    const common = [1, 3, 5, 15, 30, 45, 60, 120, 240, 360, 720, 1440];
                    const parsedFromName = (() => {
                        const n = (nameHint || '').toLowerCase();
                        const m = n.match(/(\d+)\s*m/); if (m) return parseInt(m[1], 10);
                        const h = n.match(/(\d+)\s*h/); if (h) return parseInt(h[1], 10) * 60;
                        const d = n.match(/(\d+)\s*d/); if (d) return parseInt(d[1], 10) * 1440;
                        return null;
                    })();
                    let best = mode ? parseInt(mode, 10) : (parsedFromName || null);
                    if (best == null && diffs.length) {
                        const avg = Math.round(diffs.reduce((a, b) => a + b, 0) / diffs.length);
                        best = avg;
                    }
                    if (best == null) return null;
                    const nearest = common.reduce((prev, cur) => Math.abs(cur - best) < Math.abs(prev - best) ? cur : prev, common[0]);
                    return nearest;
                } catch (e) {
                    return null;
                }
            };

            const getSeriesRangeMs = (series) => {
                if (!series || !series.length) return null;
                const first = series[0] && series[0].datetime;
                const last = series[series.length - 1] && series[series.length - 1].datetime;
                if (!(first instanceof Date) || isNaN(first.getTime())) return null;
                if (!(last instanceof Date) || isNaN(last.getTime())) return null;
                return { startMs: first.getTime(), endMs: last.getTime() };
            };

            const readFileAsText = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (evt) => resolve(String(evt.target.result || ''));
                    reader.onerror = () => reject(new Error('Error de lectura del archivo'));
                    reader.readAsText(file);
                });
            };

            const parseCsvText = (text, nameHint) => {
                const lines = String(text || '').split('\n').filter(l => l.trim());
                if (lines.length < 2) throw new Error('El archivo CSV está vacío o no tiene datos suficientes');

                const header = (lines[0] || '').split(',').map(s => s.trim());
                const isExtended = header.includes('Buy Pressure %') || header.length >= 10;
                if (!isExtended && header.length < 6) throw new Error('Formato de columnas no reconocido. Se espera OHLC estándar.');

                const parsed = lines.slice(1).map((line, idx) => {
                    const parts = line.split(',').map(s => s.trim());
                    if (isExtended) {
                        const [dtRaw, o, h, l, c, vol, trades, takerBuy, takerSell, delta, bp, status] = parts;
                        const dt = parseFlexibleDateTime(dtRaw);
                        return {
                            id: idx,
                            dateIso: dtRaw,
                            open: parseFloat(o),
                            high: parseFloat(h),
                            low: parseFloat(l),
                            close: parseFloat(c),
                            volume: parseFloat(vol),
                            trades: parseFloat(trades),
                            takerBuyVol: parseFloat(takerBuy),
                            takerSellVol: parseFloat(takerSell),
                            delta: parseFloat(delta),
                            buyPressurePct: parseFloat(bp),
                            status: status,
                            datetime: dt
                        };
                    }
                    const [d, t, o, h, l, c] = parts;
                    const dt = parseCustomDate(d, t) || parseFlexibleDateTime(`${d} ${t}`);
                    return {
                        id: idx,
                        dateRaw: d,
                        timeRaw: t,
                        open: parseFloat(o),
                        high: parseFloat(h),
                        low: parseFloat(l),
                        close: parseFloat(c),
                        datetime: dt
                    };
                }).filter(x => !isNaN(x.close) && x.datetime instanceof Date && !isNaN(x.datetime.getTime())).sort((a, b) => a.datetime - b.datetime);

                if (!parsed.length) throw new Error('No se pudieron procesar velas válidas. Verifique el formato de fecha y números.');

                const enriched = calculateIndicators(parsed);
                const tfMin = inferTfMinutesFromSeries(enriched, nameHint);
                return { enriched, tfMin, isExtended };
            };

            const intervalToMs = (interval) => {
                const m = String(interval || '').match(/^(\d+)([mhdw])$/i);
                if (!m) return null;
                const n = parseInt(m[1], 10);
                const unit = m[2].toLowerCase();
                if (!n || n <= 0) return null;
                if (unit === 'm') return n * 60 * 1000;
                if (unit === 'h') return n * 60 * 60 * 1000;
                if (unit === 'd') return n * 24 * 60 * 60 * 1000;
                if (unit === 'w') return n * 7 * 24 * 60 * 60 * 1000;
                return null;
            };

            const intervalToMinutes = (interval) => {
                const ms = intervalToMs(interval);
                return ms != null ? Math.round(ms / 60000) : null;
            };

            const sleep = (ms) => new Promise((r) => window.setTimeout(r, ms));

            const TWELVE_LIMIT_PER_MIN = 8;

            const runTwelveQueue = () => {
                const bucket = twelveRateRef.current;
                const now = Date.now();
                if (bucket.windowStart === 0 || now - bucket.windowStart >= 60000) {
                    bucket.windowStart = now;
                    bucket.count = 0;
                }

                if (!bucket.queue.length) {
                    if (bucket.timer) {
                        clearTimeout(bucket.timer);
                        bucket.timer = null;
                    }
                    return;
                }

                if (bucket.count >= TWELVE_LIMIT_PER_MIN) {
                    const waitMs = Math.max(0, 60000 - (now - bucket.windowStart));
                    if (!bucket.timer) {
                        bucket.timer = window.setTimeout(() => {
                            bucket.timer = null;
                            runTwelveQueue();
                        }, waitMs);
                    }
                    return;
                }

                const item = bucket.queue.shift();
                bucket.count += 1;
                Promise.resolve()
                    .then(item.fn)
                    .then(item.resolve)
                    .catch(item.reject)
                    .finally(() => {
                        window.setTimeout(runTwelveQueue, 0);
                    });
            };

            const scheduleTwelveTask = (fn) => {
                return new Promise((resolve, reject) => {
                    twelveRateRef.current.queue.push({ fn, resolve, reject });
                    runTwelveQueue();
                });
            };

            const buildAutoRange = (startDateStr, endDateStr) => {
                if (!startDateStr || !endDateStr) return null;
                const startLocal = new Date(`${startDateStr}T00:00:00`);
                const endLocal = new Date(`${endDateStr}T23:59:59.999`);
                if (!(startLocal instanceof Date) || isNaN(startLocal.getTime())) return null;
                if (!(endLocal instanceof Date) || isNaN(endLocal.getTime())) return null;
                const nowMs = Date.now();
                const effectiveEnd = endLocal.getTime() >= nowMs ? nowMs : endLocal.getTime();
                return { startMs: startLocal.getTime(), endMs: effectiveEnd };
            };

            const expectedCandlesForRange = (startMs, endMs, interval) => {
                const ms = intervalToMs(interval);
                if (!ms) return 0;
                const span = Math.max(0, endMs - startMs);
                return Math.max(1, Math.floor(span / ms) + 2);
            };

            const isForexOpenUtc = (ms) => {
                const d = new Date(ms);
                const day = d.getUTCDay();
                const hour = d.getUTCHours();
                if (day === 6) return false;
                if (day === 0) return hour >= 22;
                if (day >= 1 && day <= 4) return true;
                if (day === 5) return hour < 22;
                return false;
            };

            const expectedCandlesForRangeForex = (startMs, endMs, interval) => {
                const ms = intervalToMs(interval);
                if (!ms) return 0;
                const end = Math.max(startMs, endMs);
                let t = startMs;
                let count = 0;
                let guard = 0;
                const maxIter = Math.ceil(((end - startMs) / ms) + 10);

                while (t <= end && guard <= maxIter) {
                    if (isForexOpenUtc(t)) count += 1;
                    t += ms;
                    guard += 1;
                }
                return Math.max(1, count + 1);
            };

            const expectedCandlesForRangeByMarket = (startMs, endMs, interval, market) => {
                if (market === 'forex') return expectedCandlesForRangeForex(startMs, endMs, interval);
                return expectedCandlesForRange(startMs, endMs, interval);
            };

            const TWELVE_INTERVAL_MAP = {
                '5m': '5min',
                '15m': '15min',
                '1h': '1h',
                '4h': '4h',
                '1d': '1day',
                '1w': '1week'
            };

            const TWELVE_MAX_POINTS = 5000;

            const normalizeTwelveSymbol = (raw) => {
                const s = String(raw || '').trim();
                if (!s) return '';
                const upper = s.toUpperCase();
                if (upper === 'XAUUSD') return 'XAU/USD';
                return upper;
            };

            const parseTwelveDatetimeUtc = (raw) => {
                const s = String(raw || '').trim();
                const m = s.match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2})(?::(\d{2}))?$/);
                if (!m) return null;
                const Y = Number(m[1]);
                const M = Number(m[2]);
                const D = Number(m[3]);
                const h = Number(m[4]);
                const min = Number(m[5]);
                const sec = m[6] != null ? Number(m[6]) : 0;
                const ms = Date.UTC(Y, M - 1, D, h, min, sec);
                if (!isFinite(ms)) return null;
                return ms;
            };

            const formatUtcForTwelve = (ms) => {
                const d = new Date(ms);
                const pad = (n) => (n < 10 ? '0' + n : String(n));
                const Y = d.getUTCFullYear();
                const M = pad(d.getUTCMonth() + 1);
                const D = pad(d.getUTCDate());
                const h = pad(d.getUTCHours());
                const m = pad(d.getUTCMinutes());
                const s = pad(d.getUTCSeconds());
                return `${Y}-${M}-${D} ${h}:${m}:${s}`;
            };

            const fetchTwelveTimeSeries = async ({ symbol, interval, startMs, endMs, onProgress, signal }) => {
                const apiKey = (() => {
                    try { return localStorage.getItem('fti_twelve_api_key'); } catch (e) { return null; }
                })();
                if (!apiKey) throw new Error('No se detectó una API Key de TwelveData. Regístrala en Analizador de Mercado.');

                const mapped = TWELVE_INTERVAL_MAP[interval];
                if (!mapped) throw new Error('Temporalidad inválida');
                const intervalMs = intervalToMs(interval);
                if (!intervalMs) throw new Error('Temporalidad inválida');

                const targetEndMs = Math.min(endMs + intervalMs, Date.now() + intervalMs);

                let cursor = startMs;
                const out = [];
                let calls = 0;

                while (cursor <= targetEndMs) {
                    if (signal && signal.aborted) throw new Error('Carga cancelada');

                    const chunkEndMs = Math.min(
                        targetEndMs,
                        cursor + (TWELVE_MAX_POINTS - 1) * intervalMs
                    );

                    const url = new URL('https://api.twelvedata.com/time_series');
                    url.searchParams.set('symbol', symbol);
                    url.searchParams.set('interval', mapped);
                    url.searchParams.set('start_date', formatUtcForTwelve(cursor));
                    url.searchParams.set('end_date', formatUtcForTwelve(chunkEndMs));
                    url.searchParams.set('order', 'asc');
                    url.searchParams.set('timezone', 'UTC');
                    url.searchParams.set('format', 'JSON');
                    url.searchParams.set('outputsize', '5000');
                    url.searchParams.set('apikey', apiKey);

                    const json = await scheduleTwelveTask(async () => {
                        const res = await fetch(url.toString(), { signal });
                        if (!res.ok) {
                            let msg = `Error TwelveData (${res.status})`;
                            try {
                                const j = await res.json();
                                if (j && j.message) msg = String(j.message);
                            } catch (e) { }
                            throw new Error(msg);
                        }
                        return await res.json();
                    });
                    if (json && json.status && String(json.status).toLowerCase() !== 'ok') {
                        throw new Error(json.message || 'Respuesta inválida de TwelveData');
                    }
                    const values = Array.isArray(json && json.values) ? json.values : [];
                    if (!values.length) break;

                    let lastMs = null;
                    for (let i = 0; i < values.length; i++) {
                        const v = values[i];
                        const t = parseTwelveDatetimeUtc(v && v.datetime);
                        if (!isFinite(t) || t < cursor) continue;
                        const open = parseFloat(v.open);
                        const high = parseFloat(v.high);
                        const low = parseFloat(v.low);
                        const close = parseFloat(v.close);
                        const vol = v.volume !== undefined ? parseFloat(v.volume) : undefined;
                        if (!isFinite(open) || !isFinite(high) || !isFinite(low) || !isFinite(close)) continue;
                        out.push({ timeMs: t, open, high, low, close, volume: isFinite(vol) ? vol : undefined });
                        lastMs = t;
                    }

                    calls++;
                    if (onProgress) onProgress({ candles: out.length, calls });

                    if (!isFinite(lastMs)) break;
                    const nextCursor = lastMs + intervalMs;
                    if (!(nextCursor > cursor)) break;
                    cursor = nextCursor;

                    if (lastMs >= targetEndMs - intervalMs) break;
                }

                const byTime = new Map();
                for (let i = 0; i < out.length; i++) byTime.set(out[i].timeMs, out[i]);
                return Array.from(byTime.values()).sort((a, b) => a.timeMs - b.timeMs);
            };

            const twelveToRows = (points, interval) => {
                const intervalMs = intervalToMs(interval) || 0;
                const nowMs = Date.now();
                return (Array.isArray(points) ? points : []).map((p, idx) => {
                    const openTime = Number(p.timeMs);
                    const dt = new Date(openTime);
                    const candleEnd = openTime + intervalMs;
                    return {
                        id: idx,
                        dateIso: dt.toISOString(),
                        open: p.open,
                        high: p.high,
                        low: p.low,
                        close: p.close,
                        volume: p.volume,
                        status: candleEnd > nowMs ? 'FORMING' : 'CLOSED',
                        datetime: dt
                    };
                }).filter(x => isFinite(x.close) && x.datetime instanceof Date && !isNaN(x.datetime.getTime())).sort((a, b) => a.datetime - b.datetime);
            };

            const fetchBinanceKlines = async ({ symbol, interval, startMs, endMs, onProgress, signal, minDelayMs = 120 }) => {
                const intervalMs = intervalToMs(interval);
                if (!intervalMs) throw new Error('Temporalidad inválida');

                let cursor = startMs;
                const out = [];
                let calls = 0;
                while (cursor <= endMs) {
                    if (signal && signal.aborted) throw new Error('Carga cancelada');

                    const url = new URL('https://api.binance.com/api/v3/klines');
                    url.searchParams.set('symbol', symbol);
                    url.searchParams.set('interval', interval);
                    url.searchParams.set('startTime', String(cursor));
                    url.searchParams.set('endTime', String(endMs));
                    url.searchParams.set('limit', '1000');

                    const t0 = Date.now();
                    const res = await fetch(url.toString(), { signal });
                    if (!res.ok) {
                        let msg = `Error Binance (${res.status})`;
                        try {
                            const j = await res.json();
                            if (j && j.msg) msg = String(j.msg);
                        } catch (e) { }
                        throw new Error(msg);
                    }
                    const data = await res.json();
                    if (!Array.isArray(data) || data.length === 0) break;

                    for (let i = 0; i < data.length; i++) out.push(data[i]);
                    calls++;

                    const last = data[data.length - 1];
                    const lastOpenTime = last && last[0] != null ? Number(last[0]) : null;
                    if (!isFinite(lastOpenTime)) break;
                    cursor = lastOpenTime + intervalMs;

                    if (onProgress) onProgress({ candles: out.length, calls });
                    if (data.length < 1000) break;

                    const spent = Date.now() - t0;
                    const wait = Math.max(0, minDelayMs - spent);
                    if (wait > 0) await sleep(wait);
                }
                return out;
            };

            const klinesToExtendedRows = (klines) => {
                const nowMs = Date.now();
                return (Array.isArray(klines) ? klines : []).map((k, idx) => {
                    const openTime = Number(k[0]);
                    const open = parseFloat(k[1]);
                    const high = parseFloat(k[2]);
                    const low = parseFloat(k[3]);
                    const close = parseFloat(k[4]);
                    const volume = parseFloat(k[5]);
                    const closeTime = Number(k[6]);
                    const trades = Number(k[8]);
                    const takerBuyVol = parseFloat(k[9]);
                    const vol = isFinite(volume) ? volume : 0;
                    const buy = isFinite(takerBuyVol) ? takerBuyVol : 0;
                    const sell = Math.max(0, vol - buy);
                    const delta = buy - sell;
                    const bp = vol > 0 ? (buy / vol) * 100 : 0;
                    const status = isFinite(closeTime) && closeTime > nowMs ? 'FORMING' : 'CLOSED';
                    const dt = new Date(openTime);
                    return {
                        id: idx,
                        dateIso: dt.toISOString(),
                        open,
                        high,
                        low,
                        close,
                        volume: vol,
                        trades,
                        takerBuyVol: buy,
                        takerSellVol: sell,
                        delta,
                        buyPressurePct: bp,
                        status,
                        datetime: dt
                    };
                }).filter(x => isFinite(x.close) && x.datetime instanceof Date && !isNaN(x.datetime.getTime())).sort((a, b) => a.datetime - b.datetime);
            };

            const closeAutoLoad = () => {
                try {
                    if (autoAbortRef.current) autoAbortRef.current.abort();
                } catch (e) { }
                autoAbortRef.current = null;
                setAutoLoadPhase('idle');
                setAutoLoadError(null);
                setAutoProgress({
                    main: { status: 'idle', candles: 0, expected: 0, calls: 0 },
                    htf: { status: 'idle', candles: 0, expected: 0, calls: 0 },
                    ltf: { status: 'idle', candles: 0, expected: 0, calls: 0 }
                });
                setIsAutoLoadOpen(false);
            };

            const openAutoLoad = () => {
                refreshTwelveApiKeyStatus();
                setAutoLoadPhase('idle');
                setAutoLoadError(null);
                setAutoProgress({
                    main: { status: 'idle', candles: 0, expected: 0, calls: 0 },
                    htf: { status: 'idle', candles: 0, expected: 0, calls: 0 },
                    ltf: { status: 'idle', candles: 0, expected: 0, calls: 0 }
                });
                setIsAutoLoadOpen(true);
            };

            const startAutoLoad = async () => {
                const tfConf = AUTOLOAD_TF_MAP[autoEntryTf];
                if (!tfConf) return;
                const range = buildAutoRange(autoStartDate, autoEndDate);
                if (!range) return;
                if (range.endMs <= range.startMs) return;

                const isForex = autoMarket === 'forex';
                const symbol = isForex ? normalizeTwelveSymbol(autoSymbol) : autoSymbol;
                if (isForex && !autoHasTwelveApiKey) {
                    setAutoLoadError('No se detectó una API Key de TwelveData. Regístrala en Analizador de Mercado.');
                    setAutoLoadPhase('error');
                    return;
                }

                setAutoLoadError(null);
                setAutoLoadPhase('loading');

                const controller = new AbortController();
                autoAbortRef.current = controller;
                const { signal } = controller;

                const mainInterval = autoEntryTf;
                const htfInterval = tfConf.htf;
                const ltfInterval = tfConf.ltf;

                const mainExpected = expectedCandlesForRangeByMarket(range.startMs, range.endMs, mainInterval, isForex ? 'forex' : 'crypto');
                const htfExpected = expectedCandlesForRangeByMarket(range.startMs, range.endMs, htfInterval, isForex ? 'forex' : 'crypto');
                const ltfExpectedFull = expectedCandlesForRangeByMarket(range.startMs, range.endMs, ltfInterval, isForex ? 'forex' : 'crypto');

                setAutoProgress({
                    main: { status: 'loading', candles: 0, expected: mainExpected, calls: 0 },
                    htf: { status: 'idle', candles: 0, expected: htfExpected, calls: 0 },
                    ltf: { status: 'idle', candles: 0, expected: ltfExpectedFull, calls: 0 }
                });

                try {
                    const mainDataset = isForex
                        ? await fetchTwelveTimeSeries({
                            symbol,
                            interval: mainInterval,
                            startMs: range.startMs,
                            endMs: range.endMs,
                            signal,
                            onProgress: ({ candles, calls }) => setAutoProgress((p) => ({
                                ...p,
                                main: { ...p.main, status: 'loading', candles, calls }
                            }))
                        })
                        : await fetchBinanceKlines({
                            symbol,
                            interval: mainInterval,
                            startMs: range.startMs,
                            endMs: range.endMs,
                            signal,
                            onProgress: ({ candles, calls }) => setAutoProgress((p) => ({
                                ...p,
                                main: { ...p.main, status: 'loading', candles, calls }
                            }))
                        });
                    const mainRowsFinal = isForex ? twelveToRows(mainDataset, mainInterval) : klinesToExtendedRows(mainDataset);
                    const mainEnriched = calculateIndicators(mainRowsFinal);
                    setFileError(null);
                    const symbolForFile = String(autoSymbol || '').replace(/[^a-z0-9]/gi, '');
                    setFileName(`AUTO_${symbolForFile}_${AUTOLOAD_TF_LABEL[mainInterval] || mainInterval}_${autoStartDate}_${autoEndDate}.csv`);
                    setCsvData(mainEnriched);
                    if (mainEnriched.length) setSelectedCandleIndex(mainEnriched.length - 1);
                    setTfMinutes(intervalToMinutes(mainInterval));
                    setAutoProgress((p) => ({ ...p, main: { ...p.main, status: 'done', candles: mainRowsFinal.length, calls: p.main.calls } }));

                    setAutoProgress((p) => ({ ...p, htf: { ...p.htf, status: 'loading' } }));
                    const htfDataset = isForex
                        ? await fetchTwelveTimeSeries({
                            symbol,
                            interval: htfInterval,
                            startMs: range.startMs,
                            endMs: range.endMs,
                            signal,
                            onProgress: ({ candles, calls }) => setAutoProgress((p) => ({
                                ...p,
                                htf: { ...p.htf, status: 'loading', candles, calls }
                            }))
                        })
                        : await fetchBinanceKlines({
                            symbol,
                            interval: htfInterval,
                            startMs: range.startMs,
                            endMs: range.endMs,
                            signal,
                            onProgress: ({ candles, calls }) => setAutoProgress((p) => ({
                                ...p,
                                htf: { ...p.htf, status: 'loading', candles, calls }
                            }))
                        });
                    const htfRows = isForex ? twelveToRows(htfDataset, htfInterval) : klinesToExtendedRows(htfDataset);
                    const htfEnriched = calculateIndicators(htfRows);
                    setHtfError(null);
                    const symbolForFile2 = String(autoSymbol || '').replace(/[^a-z0-9]/gi, '');
                    setHtfFileName(`AUTO_${symbolForFile2}_${AUTOLOAD_TF_LABEL[htfInterval] || htfInterval}_${autoStartDate}_${autoEndDate}.csv`);
                    setHtfData(htfEnriched);
                    setHtfTfMinutes(intervalToMinutes(htfInterval));
                    setAutoProgress((p) => ({ ...p, htf: { ...p.htf, status: 'done', candles: htfRows.length, calls: p.htf.calls } }));

                    const ltfIntervalMs = intervalToMs(ltfInterval);
                    const maxLtf = ltfMaxCandles && isFinite(ltfMaxCandles) ? Number(ltfMaxCandles) : null;
                    const ltfStartMs = (ltfIntervalMs && maxLtf && maxLtf > 0)
                        ? Math.max(range.startMs, range.endMs - (maxLtf + 50) * ltfIntervalMs)
                        : range.startMs;
                    const ltfExpected = expectedCandlesForRangeByMarket(ltfStartMs, range.endMs, ltfInterval, isForex ? 'forex' : 'crypto');
                    setAutoProgress((p) => ({ ...p, ltf: { ...p.ltf, status: 'loading', expected: ltfExpected } }));

                    const ltfDataset = isForex
                        ? await fetchTwelveTimeSeries({
                            symbol,
                            interval: ltfInterval,
                            startMs: ltfStartMs,
                            endMs: range.endMs,
                            signal,
                            onProgress: ({ candles, calls }) => setAutoProgress((p) => ({
                                ...p,
                                ltf: { ...p.ltf, status: 'loading', candles, calls }
                            }))
                        })
                        : await fetchBinanceKlines({
                            symbol,
                            interval: ltfInterval,
                            startMs: ltfStartMs,
                            endMs: range.endMs,
                            signal,
                            onProgress: ({ candles, calls }) => setAutoProgress((p) => ({
                                ...p,
                                ltf: { ...p.ltf, status: 'loading', candles, calls }
                            }))
                        });
                    let ltfRows = isForex ? twelveToRows(ltfDataset, ltfInterval) : klinesToExtendedRows(ltfDataset);
                    if (maxLtf && ltfRows.length > maxLtf) ltfRows = ltfRows.slice(ltfRows.length - maxLtf);
                    const ltfEnriched = calculateIndicators(ltfRows);
                    setLtfError(null);
                    const symbolForFile3 = String(autoSymbol || '').replace(/[^a-z0-9]/gi, '');
                    setLtfFileName(`AUTO_${symbolForFile3}_${AUTOLOAD_TF_LABEL[ltfInterval] || ltfInterval}_${autoStartDate}_${autoEndDate}.csv`);
                    setLtfData(ltfEnriched);
                    setLtfTfMinutes(intervalToMinutes(ltfInterval));
                    setAutoProgress((p) => ({ ...p, ltf: { ...p.ltf, status: 'done', candles: ltfRows.length, calls: p.ltf.calls } }));

                    setAutoLoadPhase('success');
                    window.setTimeout(() => closeAutoLoad(), 2500);
                } catch (e) {
                    const msg = e && e.message ? String(e.message) : 'Error en carga automática';
                    setAutoLoadError(msg);
                    setAutoLoadPhase('error');
                } finally {
                    autoAbortRef.current = null;
                }
            };

            const processFile = (file) => {
                if (!file) return;

                // Validación básica de extensión
                if (!file.name.toLowerCase().endsWith('.csv')) {
                    setFileError('El archivo debe tener extensión .CSV');
                    setFileName(file.name);
                    setCsvData([]);
                    return;
                }

                setFileError(null);
                setFileName(file.name);

                readFileAsText(file).then((txt) => {
                    const { enriched, tfMin } = parseCsvText(txt, file.name);
                    setCsvData(enriched);
                    if (enriched.length) setSelectedCandleIndex(enriched.length - 1);
                    setTfMinutes(tfMin);
                }).catch((err) => {
                    console.error(err);
                    setFileError(err.message || 'Error procesando el archivo CSV');
                    setCsvData([]);
                });
            };

            const processHtfFile = (file) => {
                if (!file) return;
                if (!file.name.toLowerCase().endsWith('.csv')) {
                    setHtfError('El archivo debe tener extensión .CSV');
                    setHtfFileName(file.name);
                    setHtfData([]);
                    return;
                }
                setHtfError(null);
                setHtfFileName(file.name);

                readFileAsText(file).then((txt) => {
                    const { enriched, tfMin } = parseCsvText(txt, file.name);
                    const range = getSeriesRangeMs(csvData);
                    let next = enriched;
                    if (range) {
                        const pad = Math.max(0, (tfMinutes || 0) * 60000);
                        const startMs = range.startMs - pad;
                        const endMs = range.endMs + pad;
                        next = enriched.filter(x => x.datetime && x.datetime.getTime && x.datetime.getTime() >= startMs && x.datetime.getTime() <= endMs);
                    }
                    setHtfData(next);
                    setHtfTfMinutes(tfMin);
                }).catch((err) => {
                    console.error(err);
                    setHtfError(err.message || 'Error procesando el CSV HTF');
                    setHtfData([]);
                });
            };

            const processLtfFile = (file) => {
                if (!file) return;
                if (!file.name.toLowerCase().endsWith('.csv')) {
                    setLtfError('El archivo debe tener extensión .CSV');
                    setLtfFileName(file.name);
                    setLtfData([]);
                    return;
                }
                setLtfError(null);
                setLtfFileName(file.name);

                readFileAsText(file).then((txt) => {
                    const { enriched, tfMin } = parseCsvText(txt, file.name);
                    const range = getSeriesRangeMs(csvData);
                    let next = enriched;
                    if (range) {
                        const pad = Math.max(0, (tfMinutes || 0) * 60000);
                        const startMs = range.startMs - pad;
                        const endMs = range.endMs + pad;
                        next = enriched.filter(x => x.datetime && x.datetime.getTime && x.datetime.getTime() >= startMs && x.datetime.getTime() <= endMs);
                    }
                    if (ltfMaxCandles && next.length > ltfMaxCandles) {
                        next = next.slice(next.length - ltfMaxCandles);
                    }
                    setLtfData(next);
                    setLtfTfMinutes(tfMin);
                }).catch((err) => {
                    console.error(err);
                    setLtfError(err.message || 'Error procesando el CSV LTF');
                    setLtfData([]);
                });
            };

            const handleFileUpload = (e) => {
                processFile(e.target.files[0]);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                setIsDragging(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                setIsDragging(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(false);
                if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                    processFile(e.dataTransfer.files[0]);
                }
            };

            useEffect(() => {
                if (isRestoringRef.current) return;
                const range = getSeriesRangeMs(csvData);
                if (!range) return;
                if (htfData && htfData.length) {
                    const pad = Math.max(0, (tfMinutes || 0) * 60000);
                    const startMs = range.startMs - pad;
                    const endMs = range.endMs + pad;
                    const next = htfData.filter(x => x.datetime && x.datetime.getTime && x.datetime.getTime() >= startMs && x.datetime.getTime() <= endMs);
                    if (next.length !== htfData.length) setHtfData(next);
                }
                if (ltfData && ltfData.length) {
                    const pad = Math.max(0, (tfMinutes || 0) * 60000);
                    const startMs = range.startMs - pad;
                    const endMs = range.endMs + pad;
                    let next = ltfData.filter(x => x.datetime && x.datetime.getTime && x.datetime.getTime() >= startMs && x.datetime.getTime() <= endMs);
                    if (ltfMaxCandles && next.length > ltfMaxCandles) {
                        next = next.slice(next.length - ltfMaxCandles);
                    }
                    if (next.length !== ltfData.length) setLtfData(next);
                }
            }, [csvData, tfMinutes, ltfMaxCandles, htfData, ltfData]);

            // SYNC ENTRY PRICE
            useEffect(() => {
                if (isRestoringRef.current) return;
                if (csvData[selectedCandleIndex]) {
                    const c = csvData[selectedCandleIndex];
                    setEntryPrice(c.close);
                    if (c.rsi) setTargetRsi(parseFloat(c.rsi.toFixed(2)));
                    if (c.sma200) setTrendCondition(c.close > c.sma200 ? 'ABOVE' : 'BELOW');
                }
            }, [selectedCandleIndex, csvData]);

            const htfIndex = useMemo(() => {
                const times = [];
                const rows = [];
                for (let i = 0; i < htfData.length; i++) {
                    const x = htfData[i];
                    if (x && x.datetime instanceof Date && !isNaN(x.datetime.getTime())) {
                        times.push(x.datetime.getTime());
                        rows.push(x);
                    }
                }
                return { times, rows };
            }, [htfData]);

            const ltfIndex = useMemo(() => {
                const times = [];
                const rows = [];
                for (let i = 0; i < ltfData.length; i++) {
                    const x = ltfData[i];
                    if (x && x.datetime instanceof Date && !isNaN(x.datetime.getTime())) {
                        times.push(x.datetime.getTime());
                        rows.push(x);
                    }
                }
                return { times, rows };
            }, [ltfData]);

            // --- SIMULACION & OPTIMIZACION ---

            // Función pura de backtest desacoplada del estado para permitir iteraciones rápidas
            const calculateBacktest = (data, targetIdx, tradeParams, filters) => {
                if (!data || !data.length) return { error: 'Sin datos' };
                if (targetIdx == null || targetIdx < 0 || targetIdx >= data.length) return { error: 'Índice objetivo inválido' };
                const target = data[targetIdx];
                if (!target) return { error: 'Vela objetivo inválida' };

                // Walk-Forward Analysis: Support for custom index ranges
                const maxIndexExclusive = filters.maxIndexExclusive != null ? filters.maxIndexExclusive : targetIdx;
                const minIndexInclusive = filters.minIndexInclusive != null ? Math.max(200, filters.minIndexInclusive) : 200;
                const iStart = minIndexInclusive;
                const iEndExclusive = Math.min(maxIndexExclusive, data.length - 1);
                if (iEndExclusive <= iStart) return { error: 'No hay suficiente histórico en el rango especificado.' };

                const {
                    useRsi, rsiTol,
                    useTrend, trendCond,
                    useTime, timeMode: tm,
                    useVolBody,
                    useVol, volTol,
                    useBp, bpTol,
                    useDelta,
                    useCooldown,
                    useAdr,
                    useHtf,
                    htfMode: hm,
                    requireHtf: reqHtf,
                    useLtfIntra: useIntra,
                    maxDurationLimit = 500,
                    // Regime Filter
                    useRegime,
                    adxThreshold: adxThresh = 25
                } = filters;

                const epBase = Number(tradeParams.entryPrice);
                const slBase = Number(tradeParams.stopLoss);
                const tpBase = Number(tradeParams.takeProfit);
                const spreadAbs = Math.max(0, Number(tradeParams.spread) || 0);
                if (!isFinite(epBase) || epBase <= 0 || !isFinite(slBase) || !isFinite(tpBase)) return { error: 'Parámetros inválidos (Entry/SL/TP).' };

                const spreadHalf = spreadAbs / 2;
                const normalizeTradeLevels = () => {
                    if (tradeParams.tradeType === 'LONG') {
                        return {
                            entry: epBase + spreadHalf,
                            sl: slBase + spreadHalf,
                            tp: tpBase - spreadHalf
                        };
                    }
                    return {
                        entry: epBase - spreadHalf,
                        sl: slBase - spreadHalf,
                        tp: tpBase + spreadHalf
                    };
                };

                const baseLevels = normalizeTradeLevels();
                if (tradeParams.tradeType === 'LONG') {
                    if (!(baseLevels.sl < baseLevels.entry)) return { error: 'Configuración inválida (SL/Spread) en LONG.' };
                    if (!(baseLevels.tp > baseLevels.entry)) return { error: 'Configuración inválida (TP/Spread) en LONG.' };
                } else {
                    if (!(baseLevels.sl > baseLevels.entry)) return { error: 'Configuración inválida (SL/Spread) en SHORT.' };
                    if (!(baseLevels.tp < baseLevels.entry)) return { error: 'Configuración inválida (TP/Spread) en SHORT.' };
                }

                const riskDist = Math.abs((baseLevels.entry - baseLevels.sl) / baseLevels.entry);
                const tpDist = Math.abs((baseLevels.tp - baseLevels.entry) / baseLevels.entry);
                if (!isFinite(riskDist) || riskDist <= 0) return { error: 'Distancia de riesgo inválida.' };
                if (!isFinite(tpDist) || tpDist <= 0) return { error: 'Distancia de beneficio inválida.' };

                const getHour = (x) => {
                    const h = (tm === 'UTC') ? x.hourUtc : x.hourLocal;
                    return (typeof h === 'number' && isFinite(h)) ? h : null;
                };

                const getHtfCandleAtMs = (tMs) => {
                    if (!htfIndex || !htfIndex.times || !htfIndex.times.length) return null;
                    const pos = lowerBound(htfIndex.times, tMs) - 1;
                    if (pos < 0) return null;
                    const c = htfIndex.rows[pos];
                    if (!c || !(c.datetime instanceof Date)) return null;
                    const tf = htfTfMinutes;
                    if (!tf || !isFinite(tf)) return null;
                    const startMs = c.datetime.getTime();
                    const endMs = startMs + tf * 60000;
                    if (tMs < startMs || tMs >= endMs) return null;
                    return c;
                };

                const getLtfSlice = (startMs, endMs) => {
                    if (!ltfIndex || !ltfIndex.times || !ltfIndex.times.length) return null;
                    const startPos = lowerBound(ltfIndex.times, startMs);
                    if (startPos >= ltfIndex.times.length) return null;
                    const out = [];
                    for (let i = startPos; i < ltfIndex.times.length; i++) {
                        const t = ltfIndex.times[i];
                        if (t >= endMs) break;
                        const c = ltfIndex.rows[i];
                        if (c) out.push(c);
                    }
                    return out;
                };

                if (useRsi && (target.rsi == null || !isFinite(target.rsi))) return { error: 'RSI no disponible en la vela objetivo.' };
                if (useVolBody && (target.bodySizePct == null || !isFinite(target.bodySizePct))) return { error: 'Volatilidad de vela no disponible en la vela objetivo.' };
                if (useVol && (target.volume == null || !isFinite(target.volume))) return { error: 'Volumen no disponible en la vela objetivo.' };
                if (useBp && (target.buyPressurePct == null || !isFinite(target.buyPressurePct))) return { error: 'Presión compradora no disponible en la vela objetivo.' };
                if (useDelta && (target.delta == null || !isFinite(target.delta))) return { error: 'Delta no disponible en la vela objetivo.' };
                if (useRegime && (target.adx == null || !isFinite(target.adx))) return { error: 'ADX no disponible en la vela objetivo.' };

                const simulateTrade = (startIdx) => {
                    const startMid = data[startIdx].close;
                    const entryEff = (tradeParams.tradeType === 'LONG') ? (startMid + spreadHalf) : (startMid - spreadHalf);
                    const simSL = tradeParams.tradeType === 'LONG' ? entryEff * (1 - riskDist) : entryEff * (1 + riskDist);
                    const simTP = tradeParams.tradeType === 'LONG' ? entryEff * (1 + tpDist) : entryEff * (1 - tpDist);

                    let outcome = 'TIMEOUT';
                    let duration = 0;
                    let worst = entryEff;
                    let exitIdx = null;
                    let intraResolved = false;
                    let ambiguousHit = false;

                    const jMaxExclusive = Math.min(data.length, maxIndexExclusive);
                    for (let j = startIdx + 1; j < jMaxExclusive; j++) {
                        duration++;
                        const fut = data[j];

                        const o = fut && typeof fut.open === 'number' ? fut.open : NaN;
                        const h = fut && typeof fut.high === 'number' ? fut.high : NaN;
                        const l = fut && typeof fut.low === 'number' ? fut.low : NaN;
                        const openOk = isFinite(o);
                        const highOk = isFinite(h);
                        const lowOk = isFinite(l);

                        if (tradeParams.tradeType === 'LONG') {
                            if (lowOk) worst = Math.min(worst, l);
                            if (openOk) worst = Math.min(worst, o);

                            if (openOk && o <= simSL) { outcome = 'LOSS'; exitIdx = j; break; }
                            if (openOk && o >= simTP) { outcome = 'WIN'; exitIdx = j; break; }

                            const hitSL = lowOk && l <= simSL;
                            const hitTP = highOk && h >= simTP;
                            if (hitSL && hitTP) {
                                ambiguousHit = true;
                                if (useIntra && tfMinutes && isFinite(tfMinutes)) {
                                    const startMs = fut.datetime instanceof Date ? fut.datetime.getTime() : null;
                                    if (startMs != null) {
                                        const endMs = startMs + tfMinutes * 60000;
                                        const slice = getLtfSlice(startMs, endMs);
                                        if (slice && slice.length) {
                                            let intraWorst = worst;
                                            let resolved = null;
                                            for (let k = 0; k < slice.length; k++) {
                                                const s = slice[k];
                                                const so = typeof s.open === 'number' ? s.open : NaN;
                                                const sh = typeof s.high === 'number' ? s.high : NaN;
                                                const sl = typeof s.low === 'number' ? s.low : NaN;
                                                const openS = isFinite(so);
                                                const highS = isFinite(sh);
                                                const lowS = isFinite(sl);
                                                if (lowS) intraWorst = Math.min(intraWorst, sl);
                                                if (openS) intraWorst = Math.min(intraWorst, so);
                                                if (openS && so <= simSL) { resolved = 'LOSS'; break; }
                                                if (openS && so >= simTP) { resolved = 'WIN'; break; }
                                                const slHit = lowS && sl <= simSL;
                                                const tpHit = highS && sh >= simTP;
                                                if (slHit && tpHit) { resolved = 'LOSS'; break; }
                                                if (slHit) { resolved = 'LOSS'; break; }
                                                if (tpHit) { resolved = 'WIN'; break; }
                                            }
                                            if (resolved) {
                                                worst = intraWorst;
                                                outcome = resolved;
                                                exitIdx = j;
                                                intraResolved = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                outcome = 'LOSS';
                                exitIdx = j;
                                break;
                            }
                            if (hitSL) { outcome = 'LOSS'; exitIdx = j; break; }
                            if (hitTP) { outcome = 'WIN'; exitIdx = j; break; }
                        } else {
                            if (highOk) worst = Math.max(worst, h);
                            if (openOk) worst = Math.max(worst, o);

                            if (openOk && o >= simSL) { outcome = 'LOSS'; exitIdx = j; break; }
                            if (openOk && o <= simTP) { outcome = 'WIN'; exitIdx = j; break; }

                            const hitSL = highOk && h >= simSL;
                            const hitTP = lowOk && l <= simTP;
                            if (hitSL && hitTP) {
                                ambiguousHit = true;
                                if (useIntra && tfMinutes && isFinite(tfMinutes)) {
                                    const startMs = fut.datetime instanceof Date ? fut.datetime.getTime() : null;
                                    if (startMs != null) {
                                        const endMs = startMs + tfMinutes * 60000;
                                        const slice = getLtfSlice(startMs, endMs);
                                        if (slice && slice.length) {
                                            let intraWorst = worst;
                                            let resolved = null;
                                            for (let k = 0; k < slice.length; k++) {
                                                const s = slice[k];
                                                const so = typeof s.open === 'number' ? s.open : NaN;
                                                const sh = typeof s.high === 'number' ? s.high : NaN;
                                                const sl = typeof s.low === 'number' ? s.low : NaN;
                                                const openS = isFinite(so);
                                                const highS = isFinite(sh);
                                                const lowS = isFinite(sl);
                                                if (highS) intraWorst = Math.max(intraWorst, sh);
                                                if (openS) intraWorst = Math.max(intraWorst, so);
                                                if (openS && so >= simSL) { resolved = 'LOSS'; break; }
                                                if (openS && so <= simTP) { resolved = 'WIN'; break; }
                                                const slHit = highS && sh >= simSL;
                                                const tpHit = lowS && sl <= simTP;
                                                if (slHit && tpHit) { resolved = 'LOSS'; break; }
                                                if (slHit) { resolved = 'LOSS'; break; }
                                                if (tpHit) { resolved = 'WIN'; break; }
                                            }
                                            if (resolved) {
                                                worst = intraWorst;
                                                outcome = resolved;
                                                exitIdx = j;
                                                intraResolved = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                outcome = 'LOSS';
                                exitIdx = j;
                                break;
                            }
                            if (hitSL) { outcome = 'LOSS'; exitIdx = j; break; }
                            if (hitTP) { outcome = 'WIN'; exitIdx = j; break; }
                        }

                        if (duration > maxDurationLimit) break;
                    }

                    return { outcome, duration, worst, entryEff, exitIdx, intraResolved, ambiguousHit };
                };

                const wilsonLowerBound = (wins, losses, z = 1.96) => {
                    const n = wins + losses;
                    if (n <= 0) return null;
                    const phat = wins / n;
                    const denom = 1 + (z * z) / n;
                    const centre = phat + (z * z) / (2 * n);
                    const adj = z * Math.sqrt((phat * (1 - phat) + (z * z) / (4 * n)) / n);
                    const lower = (centre - adj) / denom;
                    return Math.max(0, Math.min(1, lower));
                };

                let matches = 0;
                let wins = 0;
                let losses = 0;
                let totalDuration = 0;
                let minDuration = Infinity;
                let maxDurationWin = 0;
                const durationList = [];
                const pnlList = []; // NEW: Track P&L per trade for SQN calculation
                let totalMae = 0;
                let maxMae = 0;
                let totalVolAll = 0;
                let totalVolWins = 0;
                let totalBpAll = 0;
                let totalBpWins = 0;

                let htfAligned = 0;
                let htfOpposed = 0;
                let htfUnknown = 0;
                let htfFilteredOut = 0;
                let htfHighRisk = 0;

                let ltfAmbiguous = 0;
                let ltfResolved = 0;

                for (let i = iStart; i < iEndExclusive; i++) {
                    const c = data[i];
                    if (!c) continue;

                    let match = true;

                    if (useRsi) {
                        if (c.rsi == null || !isFinite(c.rsi)) match = false;
                        else if (Math.abs(c.rsi - target.rsi) > rsiTol) match = false;
                    }

                    if (useTrend && match) {
                        if (c.sma200 == null || !isFinite(c.sma200)) match = false;
                        else if (trendCond === 'ABOVE' && c.close < c.sma200) match = false;
                        else if (trendCond === 'BELOW' && c.close > c.sma200) match = false;
                    }

                    if (useTime && match) {
                        const th = getHour(target);
                        const ch = getHour(c);
                        if (th == null || ch == null) match = false;
                        else {
                            let diff = Math.abs(th - ch);
                            if (diff > 12) diff = 24 - diff;
                            if (diff > 2) match = false;
                        }
                    }

                    if (useVolBody && match) {
                        if (c.bodySizePct == null || !isFinite(c.bodySizePct)) match = false;
                        else {
                            const targetVol = target.bodySizePct;
                            const currentVol = c.bodySizePct;
                            if (currentVol < targetVol * 0.5 || currentVol > targetVol * 1.5) match = false;
                        }
                    }

                    if (useVol && match) {
                        if (c.volume == null || !isFinite(c.volume)) match = false;
                        else {
                            const low = target.volume * (1 - volTol / 100);
                            const high = target.volume * (1 + volTol / 100);
                            if (c.volume < low || c.volume > high) match = false;
                        }
                    }

                    if (useBp && match) {
                        if (c.buyPressurePct == null || !isFinite(c.buyPressurePct)) match = false;
                        else if (Math.abs(c.buyPressurePct - target.buyPressurePct) > bpTol) match = false;
                    }

                    if (useDelta && match) {
                        if (c.delta == null || !isFinite(c.delta)) match = false;
                        else if (Math.sign(target.delta) !== Math.sign(c.delta)) match = false;
                    }

                    // --- Filtro ADR: Evitar entradas con agotamiento estadístico (>100%) ---
                    if (useAdr && match) {
                        if (c.adrFilledPct != null && c.adrFilledPct > 100) {
                            match = false;
                        }
                    }

                    // --- Market Regime Filter (ADX-based, auto by target) ---
                    if (useRegime && match) {
                        if (target.adx != null && isFinite(target.adx) && c.adx != null && isFinite(c.adx)) {
                            const isTargetTrend = target.adx >= adxThresh;
                            const isCandleTrend = c.adx >= adxThresh;

                            if (isTargetTrend && !isCandleTrend) {
                                // Target in trend, discard range regimes
                                match = false;
                            } else if (!isTargetTrend && isCandleTrend) {
                                // Target in range, discard trending regimes
                                match = false;
                            }
                        }
                    }

                    if (!match) continue;

                    let isHighRisk = false;
                    if (useHtf) {
                        const tMs = c.datetime instanceof Date ? c.datetime.getTime() : null;
                        if (tMs == null) {
                            htfUnknown++;
                            if (reqHtf) { htfFilteredOut++; continue; }
                            htfHighRisk++;
                            isHighRisk = true;
                        } else {
                            const htfC = getHtfCandleAtMs(tMs);
                            if (!htfC || htfC.sma200 == null || !isFinite(htfC.sma200) || htfC.close == null || !isFinite(htfC.close)) {
                                htfUnknown++;
                                if (reqHtf) { htfFilteredOut++; continue; }
                                htfHighRisk++;
                                isHighRisk = true;
                            } else {
                                const macroDir = htfC.close >= htfC.sma200 ? 'LONG' : 'SHORT';
                                if (macroDir === tradeParams.tradeType) {
                                    htfAligned++;
                                } else {
                                    htfOpposed++;
                                    if (hm === 'DISCARD') { htfFilteredOut++; continue; }
                                    htfHighRisk++;
                                    isHighRisk = true;
                                }
                            }
                        }
                    }

                    matches++;

                    const vol = c.volume;
                    if (vol != null && isFinite(vol)) totalVolAll += vol;
                    const bp = c.buyPressurePct;
                    if (bp != null && isFinite(bp)) totalBpAll += bp;

                    const sim = simulateTrade(i);
                    if (sim.ambiguousHit) ltfAmbiguous++;
                    if (sim.intraResolved) ltfResolved++;
                    if (sim.outcome === 'WIN') {
                        wins++;
                        pnlList.push(tpDist); // Record profit as % distance
                        totalDuration += sim.duration;
                        durationList.push(sim.duration);
                        if (sim.duration < minDuration) minDuration = sim.duration;
                        if (sim.duration > maxDurationWin) maxDurationWin = sim.duration;
                        const mae = tradeParams.tradeType === 'LONG' ? (sim.entryEff - sim.worst) / sim.entryEff : (sim.worst - sim.entryEff) / sim.entryEff;
                        const maeClamped = Math.max(0, isFinite(mae) ? mae : 0);
                        totalMae += maeClamped;
                        maxMae = Math.max(maxMae, maeClamped);
                        if (vol != null && isFinite(vol)) totalVolWins += vol;
                        if (bp != null && isFinite(bp)) totalBpWins += bp;
                    } else if (sim.outcome === 'LOSS') {
                        losses++;
                        pnlList.push(-riskDist); // Record loss as negative % distance
                    }

                    if (useCooldown && sim.exitIdx != null && sim.exitIdx > i) {
                        i = Math.min(sim.exitIdx, iEndExclusive - 1);
                    }
                }

                if (matches === 0) return { error: 'No hay coincidencias' };

                const closedTrades = wins + losses;
                if (closedTrades === 0) return { error: 'Sin datos (0 operaciones cerradas en el histórico disponible).', matches, wins, losses };

                const winRateNum = (wins / closedTrades) * 100;
                const wilson = wilsonLowerBound(wins, losses);
                const wilsonLower95 = wilson != null ? (wilson * 100).toFixed(1) : null;
                const painRatio = riskDist > 0 ? (((wins > 0 ? (totalMae / wins) : 0) / riskDist) * 100) : null;

                // Calcular estadísticas avanzadas de duración
                const sortedDurations = durationList.slice().sort((a, b) => a - b);
                const medianDuration = sortedDurations.length > 0
                    ? (sortedDurations.length % 2 === 1
                        ? sortedDurations[Math.floor(sortedDurations.length / 2)]
                        : Math.round((sortedDurations[sortedDurations.length / 2 - 1] + sortedDurations[sortedDurations.length / 2]) / 2))
                    : 0;
                const p80Index = Math.ceil(sortedDurations.length * 0.8) - 1;
                const p80Duration = sortedDurations.length > 0 ? sortedDurations[Math.max(0, p80Index)] : 0;

                // Generar distribución de duraciones
                const durationDistribution = {};
                for (let d = 0; d < durationList.length; d++) {
                    const dur = durationList[d];
                    durationDistribution[dur] = (durationDistribution[dur] || 0) + 1;
                }

                // === NEW: Expectancy & SQN Calculation ===
                let expectancy = null;
                let sqn = null;
                let sqnNormalized = null;
                let sqnClassification = null;

                if (pnlList.length >= 5) {
                    // Calculate mean P&L (Expectancy)
                    const sumPnl = pnlList.reduce((acc, v) => acc + v, 0);
                    const meanPnl = sumPnl / pnlList.length;
                    expectancy = meanPnl * 100; // Convert to percentage

                    // Calculate standard deviation
                    const squaredDiffs = pnlList.map(v => Math.pow(v - meanPnl, 2));
                    const avgSquaredDiff = squaredDiffs.reduce((acc, v) => acc + v, 0) / pnlList.length;
                    const stdDev = Math.sqrt(avgSquaredDiff);

                    if (stdDev > 0) {
                        // SQN = (Mean / StdDev) × √N
                        // Standard SQN uses actual trade count
                        sqn = (meanPnl / stdDev) * Math.sqrt(pnlList.length);

                        // Normalized SQN: benchmarked to √100 to prevent HFT inflation
                        // This allows fair comparison between systems with different trade counts
                        sqnNormalized = (meanPnl / stdDev) * Math.sqrt(100);

                        // Classification based on Van Tharp's scale
                        if (sqn < 1.6) sqnClassification = 'POOR';
                        else if (sqn < 2.0) sqnClassification = 'AVERAGE';
                        else if (sqn < 2.5) sqnClassification = 'GOOD';
                        else if (sqn < 3.0) sqnClassification = 'EXCELLENT';
                        else sqnClassification = 'SUPERB';
                    }
                }


                return {
                    matches,
                    closedTrades,
                    winRate: winRateNum.toFixed(1),
                    winRateNum,
                    wilsonLower95,
                    wins,
                    losses,
                    // === NEW: SQN & Expectancy ===
                    expectancy: expectancy != null ? expectancy.toFixed(3) : null,
                    sqn: sqn != null ? sqn.toFixed(2) : null,
                    sqnNormalized: sqnNormalized != null ? sqnNormalized.toFixed(2) : null,
                    sqnClassification,
                    avgDuration: wins > 0 ? Math.round(totalDuration / wins) : 0,
                    minDuration: wins > 0 ? minDuration : 0,
                    maxDuration: wins > 0 ? maxDurationWin : 0,
                    medianDuration,
                    p80Duration,
                    durationDistribution,
                    // === Temporal Efficiency (ROI per candle) ===
                    temporalEfficiency: expectancy != null && wins > 0 && totalDuration > 0
                        ? (expectancy / (totalDuration / wins)).toFixed(4)
                        : null,
                    avgMae: wins > 0 ? ((totalMae / wins) * 100).toFixed(2) : 0,
                    maxMae: (maxMae * 100).toFixed(2),
                    painRatio: painRatio != null ? painRatio.toFixed(1) : null,
                    riskDistPercent: (riskDist * 100).toFixed(2),
                    weightedWinRateVolume: totalVolAll > 0 ? ((totalVolWins / totalVolAll) * 100).toFixed(1) : null,
                    weightedWinRateBuyPressure: totalBpAll > 0 ? ((totalBpWins / totalBpAll) * 100).toFixed(1) : null,
                    pnlList, // Devolver el array de PnL real (en unidades R)
                    htfAligned,
                    htfOpposed,
                    htfUnknown,
                    htfFilteredOut,
                    htfHighRisk,
                    ltfAmbiguous,
                    ltfResolved
                };
            };

            const handleOptimize = async () => {
                if (!csvData.length || !stopLoss || !takeProfit) return;
                setIsOptimizing(true);

                // Mínimo delay para renderizar loader
                await new Promise(r => setTimeout(r, 50));

                const tradeParams = {
                    tradeType,
                    entryPrice,
                    stopLoss,
                    takeProfit,
                    spread: Math.max(0, parseFloat(spread || '0') || 0)
                };

                // === OPTIMIZACIÓN: Solo 2 tiers para mayor velocidad ===
                const SENSITIVITY_TIERS = [
                    { key: 'NORMAL', label: '[BASE]', factor: 1.0 },
                    { key: 'LOOSE', label: '[LAXO]', factor: 1.2 }
                ];

                // Función para calcular valores numéricos según tier
                const computeTieredValues = (tierFactor) => ({
                    rsiTol: Math.max(1, Math.round(rsiTolerance * tierFactor)),
                    volTol: Math.max(5, Math.round(volumeTolerance * tierFactor)),
                    bpTol: Math.max(1, Math.round(bpTolerance * tierFactor))
                });

                // Definir qué filtros vamos a permutar (solo los booleanos)
                const toggleableFilters = [
                    { key: 'useRsi', label: 'RSI' },
                    { key: 'useTrend', label: 'Tendencia' },
                    { key: 'useTime', label: 'Horario' },
                    { key: 'useVolBody', label: 'Volatilidad' },
                    { key: 'useCooldown', label: 'Enfriamiento' },
                    { key: 'useAdr', label: 'ADR' }
                ];

                if (hasExtended) {
                    toggleableFilters.push({ key: 'useVol', label: 'Volumen' });
                    toggleableFilters.push({ key: 'useBp', label: 'Presión Compra' });
                    toggleableFilters.push({ key: 'useDelta', label: 'Delta' });
                }

                if (htfData && htfData.length) {
                    toggleableFilters.push({ key: 'useHtf', label: 'HTF' });
                    toggleableFilters.push({ key: 'requireHtf', label: 'HTF Req' });
                }

                if (ltfData && ltfData.length && tfMinutes) {
                    toggleableFilters.push({ key: 'useLtfIntra', label: 'LTF Intra' });
                }

                // === NUEVO: Integrar Filtro de Régimen ===
                toggleableFilters.push({ key: 'useRegime', label: 'Régimen' });

                const combinations = [];
                const totalCombs = 1 << toggleableFilters.length; // 2^n
                const signatureGroups = new Map();
                let robustCount = 0;

                // === OPTIMIZACIÓN: Chunk grande + procesamiento síncrono ===
                const CHUNK_SIZE = 256;
                let yieldCounter = 0;

                for (let i = 1; i < totalCombs; i++) {
                    // === OPTIMIZACIÓN: Yield cada 512 iteraciones para no congelar ===
                    yieldCounter++;
                    if (yieldCounter >= 512) {
                        yieldCounter = 0;
                        await new Promise(r => setTimeout(r, 0));
                        // Early termination si ya tenemos suficientes robustos
                        if (robustCount >= 8) break;
                    }

                    // Iterar sobre los 2 tiers
                    for (let t = 0; t < SENSITIVITY_TIERS.length; t++) {
                        const tier = SENSITIVITY_TIERS[t];
                        const tieredValues = computeTieredValues(tier.factor);

                        const currentConfig = {
                            useRsi: false, rsiTol: tieredValues.rsiTol,
                            useTrend: false, trendCond: trendCondition,
                            useTime: false, timeMode,
                            useVolBody: false,
                            useVol: false, volTol: tieredValues.volTol,
                            useBp: false, bpTol: tieredValues.bpTol,
                            useDelta: false,
                            useCooldown: false,
                            useAdr: false,
                            useHtf: false,
                            htfMode,
                            requireHtf: false,
                            useLtfIntra: false,
                            useRegime: false,
                            adxThreshold,
                            tier: tier.key,
                            tierLabel: tier.label
                        };

                        const activeLabels = [];
                        let activeCount = 0;

                        for (let j = 0; j < toggleableFilters.length; j++) {
                            if ((i >> j) & 1) {
                                currentConfig[toggleableFilters[j].key] = true;
                                activeLabels.push(toggleableFilters[j].label);
                                activeCount++;
                            }
                        }

                        // === OPTIMIZACIÓN: Skip si no hay filtros activos ===
                        if (activeCount === 0) continue;

                        // Generar firma booleana
                        const boolSignature = toggleableFilters
                            .map(f => currentConfig[f.key] ? '1' : '0')
                            .join('');

                        // === OPTIMIZACIÓN: Lógica anidada solo para HTF (régimen automático) ===
                        const modeVariants = (currentConfig.useHtf && htfData && htfData.length) ? ['DISCARD', 'MARK'] : [htfMode];

                        for (let mv = 0; mv < modeVariants.length; mv++) {

                            const cfg = {
                                ...currentConfig,
                                htfMode: modeVariants[mv]
                            };

                            const labels = [...activeLabels];
                            if (cfg.useHtf) labels.push(`HTF:${cfg.htfMode}`);
                            if (cfg.useRegime) labels.push('REG:AUTO');

                            const result = calculateBacktest(csvData, selectedCandleIndex, tradeParams, cfg);

                            if (!result.error && result.matches >= 5) {
                                const sig = boolSignature + '_' + cfg.htfMode;
                                const comb = {
                                    config: cfg,
                                    labels,
                                    stats: result,
                                    tier: tier.key,
                                    tierLabel: tier.label,
                                    boolSignature: sig
                                };
                                combinations.push(comb);

                                // === OPTIMIZACIÓN: Detección de robustez en línea ===
                                if (!signatureGroups.has(sig)) {
                                    signatureGroups.set(sig, []);
                                }
                                signatureGroups.get(sig).push(comb);

                                // Verificar robustez inmediatamente
                                const group = signatureGroups.get(sig);
                                if (group.length === 2) {
                                    const tiers = new Set(group.map(g => g.tier));
                                    if (tiers.size === 2 && group.every(g => g.stats.winRateNum >= 50)) {
                                        const normalResult = group.find(g => g.tier === 'NORMAL');
                                        if (normalResult && !normalResult.isRobust) {
                                            normalResult.isRobust = true;
                                            normalResult.robustnessScore = group.reduce((acc, g) => acc + g.stats.winRateNum, 0) / 2;
                                            robustCount++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Marcar especulativos (solo aparecen en 1 tier)
                for (const [sig, group] of signatureGroups) {
                    const tiers = new Set(group.map(g => g.tier));
                    if (tiers.size === 1 && !group[0].isRobust) {
                        const onlyTier = [...tiers][0];
                        for (const item of group) {
                            item.isSpeculative = true;
                            item.speculativeType = onlyTier;
                        }
                    }
                }

                // Ordenar: Robustos primero, luego por WinRate
                combinations.sort((a, b) => {
                    // 1. Prioridad: Robustez
                    if (a.isRobust && !b.isRobust) return -1;
                    if (!a.isRobust && b.isRobust) return 1;

                    // 2. Prioridad: Tipo de Especulación
                    if (a.isSpeculative && a.speculativeType === 'LOOSE' && !(b.isSpeculative && b.speculativeType === 'LOOSE')) return 1;
                    if (b.isSpeculative && b.speculativeType === 'LOOSE' && !(a.isSpeculative && a.speculativeType === 'LOOSE')) return -1;

                    // 3. NUEVO CRITERIO: Volumen de muestras
                    // Si la diferencia de matches es > 50, gana el que tenga más trades, independientemente de pequeñas diferencias en WR.
                    if (Math.abs(b.stats.matches - a.stats.matches) > 50) {
                        return b.stats.matches - a.stats.matches;
                    }

                    // Si la cantidad es similar, desempata por WinRate
                    if (b.stats.winRateNum !== a.stats.winRateNum) return b.stats.winRateNum - a.stats.winRateNum;
                    return b.stats.matches - a.stats.matches;
                });

                // Filtrar duplicados por firma
                const seenSignatures = new Set();
                const uniqueResults = [];

                for (const comb of combinations) {
                    if (comb.isRobust && !seenSignatures.has(comb.boolSignature)) {
                        uniqueResults.push(comb);
                        seenSignatures.add(comb.boolSignature);
                    }
                }

                for (const comb of combinations) {
                    if (!seenSignatures.has(comb.boolSignature)) {
                        uniqueResults.push(comb);
                        seenSignatures.add(comb.boolSignature);
                    }
                }

                // === SELECCIÓN FINAL DE RESULTADOS CON GARANTÍA DE MUESTRA GRANDE ===
                const finalResults = uniqueResults.slice(0, 8);

                // Buscar explícitamente la configuración ROBUSTA con mayor número de matches
                const bestHighSampleRobust = uniqueResults.reduce((best, current) => {
                    if (current.isRobust) {
                        if (!best || current.stats.matches > best.stats.matches) {
                            return current;
                        }
                    }
                    return best;
                }, null);

                // Si existe un gigante robusto y no está en el top 8, inyectarlo forzosamente
                if (bestHighSampleRobust && !finalResults.some(r => r.boolSignature === bestHighSampleRobust.boolSignature)) {
                    if (finalResults.length === 8) {
                        finalResults[7] = bestHighSampleRobust; // Reemplazar el último
                    } else {
                        finalResults.push(bestHighSampleRobust);
                    }
                }

                setOptimizationResults(finalResults);
                setIsOptimizing(false);
            };

            const applyOptimization = (config) => {
                // Aplicar estados booleanos
                if (config.useRsi !== undefined) setUseRsiFilter(config.useRsi);
                if (config.useTrend !== undefined) setUseTrendFilter(config.useTrend);
                if (config.useTime !== undefined) setUseTimeFilter(config.useTime);
                if (config.timeMode !== undefined) setTimeMode(config.timeMode);
                if (config.useVolBody !== undefined) setUseVolFilter(config.useVolBody);
                if (config.useVol !== undefined) setUseVolumeFilter(config.useVol);
                if (config.useBp !== undefined) setUseBuyPressureFilter(config.useBp);
                if (config.useDelta !== undefined) setUseDeltaSignFilter(config.useDelta);
                if (config.useCooldown !== undefined) setUseCooldownFilter(config.useCooldown);
                if (config.useAdr !== undefined) setUseAdrFilter(config.useAdr);
                if (config.useHtf !== undefined) setUseHtfFilter(config.useHtf);
                if (config.htfMode !== undefined) setHtfMode(config.htfMode);
                if (config.requireHtf !== undefined) setRequireHtf(config.requireHtf);
                if (config.useLtfIntra !== undefined) setUseLtfIntra(config.useLtfIntra);

                // === NUEVO: Aplicar Filtro de Régimen ===
                if (config.useRegime !== undefined) setUseRegimeFilter(config.useRegime);
                if (config.adxThreshold !== undefined) setAdxThreshold(config.adxThreshold);

                // === NUEVO: Aplicar valores numéricos del tier ganador ===
                if (config.rsiTol !== undefined) setRsiTolerance(config.rsiTol);
                if (config.volTol !== undefined) setVolumeTolerance(config.volTol);
                if (config.bpTol !== undefined) setBpTolerance(config.bpTol);

                // Auto-ejecutar simulación después de aplicar
                setTimeout(() => {
                    runSimulation();
                }, 150);
            };


            const runSimulation = () => {
                if (!csvData.length || !stopLoss || !takeProfit) return;

                const slVal = parseFloat(stopLoss);
                const tpVal = parseFloat(takeProfit);
                const spreadVal = Math.max(0, parseFloat(spread || '0') || 0);

                // Validaciones de lógica de mercado
                if (tradeType === 'LONG') {
                    if (slVal >= entryPrice) {
                        setSimResult({ error: "Configuración Inválida: En LONG, el Stop Loss debe ser MENOR al precio de entrada." });
                        return;
                    }
                    if (tpVal <= entryPrice) {
                        setSimResult({ error: "Configuración Inválida: En LONG, el Take Profit debe ser MAYOR al precio de entrada." });
                        return;
                    }
                } else if (tradeType === 'SHORT') {
                    if (slVal <= entryPrice) {
                        setSimResult({ error: "Configuración Inválida: En SHORT, el Stop Loss debe ser MAYOR al precio de entrada." });
                        return;
                    }
                    if (tpVal >= entryPrice) {
                        setSimResult({ error: "Configuración Inválida: En SHORT, el Take Profit debe ser MENOR al precio de entrada." });
                        return;
                    }
                }

                if (spreadVal < 0 || !isFinite(spreadVal)) {
                    setSimResult({ error: 'Spread inválido.' });
                    return;
                }

                const filters = {
                    useRsi: useRsiFilter, rsiTol: rsiTolerance,
                    useTrend: useTrendFilter, trendCond: trendCondition,
                    useTime: useTimeFilter, timeMode,
                    useVolBody: useVolFilter,
                    useVol: useVolumeFilter, volTol: volumeTolerance,
                    useBp: useBuyPressureFilter, bpTol: bpTolerance,
                    useDelta: useDeltaSignFilter,
                    useCooldown: useCooldownFilter,
                    useAdr: useAdrFilter,
                    useHtf: useHtfFilter,
                    htfMode,
                    requireHtf,
                    useLtfIntra: useLtfIntra,
                    maxDurationLimit: useMacroMode ? 5000 : 500,
                    // === REGIME FILTER ===
                    useRegime: useRegimeFilter,
                    adxThreshold
                };

                const tradeParams = { tradeType, entryPrice, stopLoss, takeProfit, spread: spreadVal };

                // === WALK-FORWARD ANALYSIS ===
                if (useWalkForward && csvData.length > 400) {
                    // Calculate split point
                    const splitIdx = Math.floor(csvData.length * (walkForwardSplit / 100));

                    // Ensure enough data in both sets (min 200 candles for indicators)
                    if (splitIdx >= 400 && (csvData.length - splitIdx) >= 100) {
                        // In-Sample: Train on first X%
                        const inSampleTarget = Math.min(splitIdx - 1, selectedCandleIndex);
                        const inSampleRes = calculateBacktest(csvData, inSampleTarget, tradeParams, { ...filters, maxIndexExclusive: splitIdx });

                        // Out-of-Sample: Test on remaining data
                        // Use selectedCandleIndex as target for out-of-sample to ensure pattern consistency
                        const outSampleTarget = selectedCandleIndex;
                        // Create modified filters that skip the in-sample period
                        const outSampleRes = calculateBacktest(csvData, outSampleTarget, tradeParams, { ...filters, minIndexInclusive: splitIdx });

                        // Calculate degradation
                        let degradation = null;
                        if (!inSampleRes.error && !outSampleRes.error && inSampleRes.sqn && outSampleRes.sqn) {
                            const inSqn = parseFloat(inSampleRes.sqn);
                            const outSqn = parseFloat(outSampleRes.sqn);
                            if (inSqn > 0) {
                                degradation = ((inSqn - outSqn) / inSqn) * 100;
                            }
                        }

                        setWalkForwardResult({
                            inSample: inSampleRes,
                            outOfSample: outSampleRes,
                            degradation,
                            splitIndex: splitIdx,
                            splitDate: csvData[splitIdx]?.datetime?.toLocaleDateString('es-ES') || null
                        });

                        // Show in-sample result as main result
                        setSimResult(inSampleRes.error ? { error: inSampleRes.error } : inSampleRes);
                    } else {
                        setWalkForwardResult(null);
                        setSimResult({ error: 'Datos insuficientes para Walk-Forward (min. 400 in-sample + 100 out-of-sample)' });
                    }
                } else {
                    setWalkForwardResult(null);
                    const res = calculateBacktest(csvData, selectedCandleIndex, tradeParams, filters);
                    setSimResult(res.error ? { error: res.error } : res);
                }

                setOptimizationResults(null); // Limpiar optimizacion anterior al correr nuevo manual
            };

            // === MONTE CARLO SIMULATION (Inline Web Worker) ===
            const runMonteCarlo = () => {
                if (!simResult || simResult.error || !simResult.closedTrades || simResult.closedTrades < 10) {
                    alert('Ejecuta primero una simulación con al menos 10 trades cerrados.');
                    return;
                }

                setIsRunningMonteCarlo(true);
                setMonteCarloResult(null);

                // Usar pnlList real del backtest para que la simulación refleje la volatilidad real
                const trades = simResult.pnlList || [];
                const riskPercent = 1; // El pnlList ya está en unidades R (1R = riskPercent)

                // Web Worker code as string
                const workerCode = `
                    self.onmessage = function(e) {
                        const { trades, simCount, riskPercent } = e.data;
                        
                        // Fisher-Yates shuffle
                        function shuffle(arr) {
                            const a = arr.slice();
                            for (let i = a.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [a[i], a[j]] = [a[j], a[i]];
                            }
                            return a;
                        }

                        const drawdowns = [];
                        const finalEquities = [];
                        const sampleCurves = [];
                        let ruinCount = 0;
                        const ruinThreshold = -50; // 50% drawdown = ruin

                        for (let sim = 0; sim < simCount; sim++) {
                            const shuffled = shuffle(trades);
                            let equity = 100;
                            let peak = 100;
                            let maxDrawdown = 0;
                            const curve = sim < 50 ? [100] : null; // Store first 50 curves for visualization
                            
                            for (let t = 0; t < shuffled.length; t++) {
                                const pnl = shuffled[t] * riskPercent;
                                equity += pnl;
                                if (curve) curve.push(equity);
                                
                                if (equity > peak) peak = equity;
                                const dd = ((equity - peak) / peak) * 100;
                                if (dd < maxDrawdown) maxDrawdown = dd;
                                
                                // Check for ruin
                                if (equity <= 50) {
                                    ruinCount++;
                                    break;
                                }
                            }
                            
                            drawdowns.push(maxDrawdown);
                            finalEquities.push(equity);
                            if (curve) sampleCurves.push(curve);
                        }

                        // Sort for percentiles
                        drawdowns.sort((a, b) => a - b);
                        finalEquities.sort((a, b) => a - b);

                        const percentile = (arr, p) => {
                            const idx = Math.floor(arr.length * p);
                            return arr[Math.min(idx, arr.length - 1)];
                        };

                        const result = {
                            worstDrawdown: drawdowns[0],
                            avgDrawdown: drawdowns.reduce((a, b) => a + b, 0) / drawdowns.length,
                            ruinProbability: (ruinCount / simCount) * 100,
                            percentiles: {
                                p5: percentile(drawdowns, 0.05),
                                p25: percentile(drawdowns, 0.25),
                                p50: percentile(drawdowns, 0.50),
                                p75: percentile(drawdowns, 0.75),
                                p95: percentile(drawdowns, 0.95)
                            },
                            equityPercentiles: {
                                p5: percentile(finalEquities, 0.05),
                                p25: percentile(finalEquities, 0.25),
                                p50: percentile(finalEquities, 0.50),
                                p75: percentile(finalEquities, 0.75),
                                p95: percentile(finalEquities, 0.95)
                            },
                            sampleCurves: sampleCurves.slice(0, 20), // Only send 20 for visualization
                            simCount
                        };

                        self.postMessage(result);
                    };
                `;

                // Create inline worker
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);
                const worker = new Worker(workerUrl);

                worker.onmessage = (e) => {
                    setMonteCarloResult(e.data);
                    setIsRunningMonteCarlo(false);
                    worker.terminate();
                    URL.revokeObjectURL(workerUrl);
                };

                worker.onerror = (err) => {
                    console.error('Monte Carlo Worker Error:', err);
                    setIsRunningMonteCarlo(false);
                    worker.terminate();
                    URL.revokeObjectURL(workerUrl);
                };

                // Send data to worker
                worker.postMessage({
                    trades,
                    simCount: monteCarloSimulations,
                    riskPercent
                });
            };

            const computeATR = (data, endIdx, period) => {
                if (!data || data.length < 2) return 0;
                const start = Math.max(1, endIdx - period + 1);
                let sum = 0;
                let count = 0;
                for (let i = start; i <= endIdx; i++) {
                    const prevClose = data[i - 1] ? data[i - 1].close : data[i].close;
                    const high = data[i].high;
                    const low = data[i].low;
                    const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(prevClose - low));
                    sum += tr;
                    count++;
                }
                return count > 0 ? sum / count : 0;
            };

            const findRecentSwingLow = (data, endIdx, lookback) => {
                const start = Math.max(1, endIdx - lookback);
                for (let i = endIdx - 1; i >= start; i--) {
                    const prev = data[i - 1];
                    const cur = data[i];
                    const next = data[i + 1];
                    if (!prev || !next) continue;
                    if (cur.low < prev.low && cur.low <= next.low) return cur.low;
                }
                return null;
            };

            const findRecentSwingHigh = (data, endIdx, lookback) => {
                const start = Math.max(1, endIdx - lookback);
                for (let i = endIdx - 1; i >= start; i--) {
                    const prev = data[i - 1];
                    const cur = data[i];
                    const next = data[i + 1];
                    if (!prev || !next) continue;
                    if (cur.high > prev.high && cur.high >= next.high) return cur.high;
                }
                return null;
            };

            const handleAutoDetect = async () => {
                if (!csvData.length) return;
                setIsAutoDetecting(true);
                await new Promise(r => setTimeout(r, 100));
                const target = csvData[selectedCandleIndex];
                const ep = target ? target.close : 0;
                if (!ep) { setIsAutoDetecting(false); return; }

                let dirPref = 'LONG';
                if (target && target.sma200 != null) dirPref = ep > target.sma200 ? 'LONG' : 'SHORT';
                if (target && target.rsi != null) {
                    if (target.rsi > 60) dirPref = 'LONG';
                    else if (target.rsi < 40) dirPref = 'SHORT';
                }
                const dirs = [dirPref, dirPref === 'LONG' ? 'SHORT' : 'LONG'];

                const atr = computeATR(csvData, selectedCandleIndex, 14);
                const swingLow = findRecentSwingLow(csvData, selectedCandleIndex, 50);
                const swingHigh = findRecentSwingHigh(csvData, selectedCandleIndex, 50);
                const minRisk = ep * 0.001;

                const candidates = [];
                for (let d = 0; d < dirs.length; d++) {
                    const dir = dirs[d];
                    if (dir === 'LONG') {
                        const sls = [];
                        if (swingLow && swingLow < ep) sls.push(swingLow);
                        sls.push(ep - atr * 1.0, ep - atr * 1.5, ep - atr * 2.0);
                        const filteredSls = sls.filter(v => v > 0 && v < ep && Math.abs(ep - v) >= minRisk);
                        for (let i = 0; i < filteredSls.length; i++) {
                            const sl = filteredSls[i];
                            const risk = ep - sl;
                            const tps = [];
                            if (swingHigh && swingHigh > ep) tps.push(swingHigh);
                            tps.push(ep + risk * 1.0, ep + risk * 1.5, ep + risk * 2.0, ep + risk * 2.5, ep + risk * 3.0);
                            const filteredTps = tps.filter(v => v > ep);
                            for (let j = 0; j < filteredTps.length; j++) {
                                const tp = filteredTps[j];
                                candidates.push({ tradeType: 'LONG', entryPrice: ep, stopLoss: sl, takeProfit: tp });
                            }
                        }
                    } else {
                        const sls = [];
                        if (swingHigh && swingHigh > ep) sls.push(swingHigh);
                        sls.push(ep + atr * 1.0, ep + atr * 1.5, ep + atr * 2.0);
                        const filteredSls = sls.filter(v => v > ep && Math.abs(v - ep) >= minRisk);
                        for (let i = 0; i < filteredSls.length; i++) {
                            const sl = filteredSls[i];
                            const risk = sl - ep;
                            const tps = [];
                            if (swingLow && swingLow < ep) tps.push(swingLow);
                            tps.push(ep - risk * 1.0, ep - risk * 1.5, ep - risk * 2.0, ep - risk * 2.5, ep - risk * 3.0);
                            const filteredTps = tps.filter(v => v < ep);
                            for (let j = 0; j < filteredTps.length; j++) {
                                const tp = filteredTps[j];
                                candidates.push({ tradeType: 'SHORT', entryPrice: ep, stopLoss: sl, takeProfit: tp });
                            }
                        }
                    }
                }

                const results = [];
                for (let k = 0; k < candidates.length; k++) {
                    const c = candidates[k];
                    const ratio = Math.abs((c.takeProfit - c.entryPrice) / (c.entryPrice - c.stopLoss));
                    const beWr = ratio > 0 ? (100 / (1 + ratio)) : null;
                    const f = {
                        useRsi: true, rsiTol: rsiTolerance,
                        useTrend: true, trendCond: c.tradeType === 'LONG' ? 'ABOVE' : 'BELOW',
                        useTime: true, timeMode,
                        useVolBody: true,
                        useVol: hasExtended, volTol: volumeTolerance,
                        useBp: hasExtended, bpTol: bpTolerance,
                        useDelta: hasExtended,
                        useCooldown: useCooldownFilter,
                        useHtf: useHtfFilter,
                        htfMode,
                        requireHtf,
                        useLtfIntra: useLtfIntra
                    };
                    const res = calculateBacktest(csvData, selectedCandleIndex, c, f);
                    if (res && !res.error && res.matches >= 30 && beWr != null) {
                        const edge = res.winRateNum - beWr;
                        results.push({ cand: c, stats: res, ratio, beWr, edge });
                    }
                }

                if (!results.length) {
                    setSimResult({ error: 'No se encontraron configuraciones de alta probabilidad en el contexto actual.' });
                    setIsAutoDetecting(false);
                    return;
                }

                results.sort((a, b) => {
                    if (b.edge !== a.edge) return b.edge - a.edge;
                    if (b.stats.matches !== a.stats.matches) return b.stats.matches - a.stats.matches;
                    return b.stats.winRateNum - a.stats.winRateNum;
                });
                const best = results[0].cand;
                setTradeType(best.tradeType);
                setStopLoss(String(best.stopLoss));
                setTakeProfit(String(best.takeProfit));
                setTimeout(() => { runSimulation(); setIsAutoDetecting(false); }, 100);
            };

            // --- DIAGNOSTICO ACTIVO ---
            const activeDiagnosis = useMemo(() => {
                if (!simResult || !currentPrice || simResult.error) return null;
                const curr = parseFloat(currentPrice);
                const ep = parseFloat(entryPrice);

                // Calcular Estado Actual
                let pnlPercent = 0;
                let drawdownPercent = 0;

                if (tradeType === 'LONG') {
                    pnlPercent = ((curr - ep) / ep) * 100;
                    if (curr < ep) drawdownPercent = Math.abs(pnlPercent);
                } else {
                    pnlPercent = ((ep - curr) / ep) * 100;
                    if (curr > ep) drawdownPercent = Math.abs(pnlPercent);
                }

                // Diagnostico de Salud (Semáforo)
                let health = 'HEALTHY'; // Green
                let msg = "Comportamiento normal dentro de los parámetros históricos.";

                const avgMae = parseFloat(simResult.avgMae);
                const maxMae = parseFloat(simResult.maxMae);

                if (pnlPercent < 0) {
                    if (drawdownPercent > maxMae) {
                        health = 'CRITICAL';
                        msg = "ANOMALÍA ESTADÍSTICA: El precio ha superado el peor retroceso histórico registrado en trades ganadores. Probabilidad de fallo muy alta.";
                    } else if (drawdownPercent > avgMae) {
                        health = 'WARNING';
                        msg = "PRECAUCIÓN: El retroceso es mayor al promedio habitual de los ganadores, pero aún dentro de límites conocidos.";
                    }
                }

                // Diagnostico de Tiempo (Semáforo Inteligente)
                const median = simResult.medianDuration || simResult.avgDuration;
                const p80 = simResult.p80Duration || simResult.avgDuration;
                let timeStatus = 'EARLY'; // Verde: < mediana
                let timeMsg = `Fase temprana. El 50% de los ganadores aún no cierra hasta la vela ${median}.`;

                if (candlesSinceEntry >= p80) {
                    timeStatus = 'TIME_STOP';
                    timeMsg = `⚠️ TIME STOP: El 80% de los ganadores ya cerraron antes de la vela ${p80}. Mover a BE obligatorio o evaluar cierre.`;
                } else if (candlesSinceEntry >= median) {
                    timeStatus = 'DECISION';
                    timeMsg = `Fase de decisión. Ya pasaron ${candlesSinceEntry} velas (mediana: ${median}). Considera BE si hay eventos cercanos.`;
                }

                return { pnlPercent, drawdownPercent, health, msg, timeStatus, timeMsg, median, p80 };

            }, [currentPrice, simResult, tradeType, entryPrice, candlesSinceEntry]);

            const rrMetrics = useMemo(() => {

                const ep = Number(entryPrice);
                const sl = parseFloat(stopLoss);
                const tp = parseFloat(takeProfit);
                const sp = Math.max(0, parseFloat(spread || '0') || 0);
                if (!ep || !sl || !tp || isNaN(ep) || isNaN(sl) || isNaN(tp) || !isFinite(sp)) return null;
                const half = sp / 2;
                let entryEff = ep;
                let slEff = sl;
                let tpEff = tp;
                if (tradeType === 'LONG') {
                    entryEff = ep + half;
                    slEff = sl + half;
                    tpEff = tp - half;
                } else {
                    entryEff = ep - half;
                    slEff = sl - half;
                    tpEff = tp + half;
                }
                let risk = 0, reward = 0;
                if (tradeType === 'LONG') { risk = entryEff - slEff; reward = tpEff - entryEff; }
                else { risk = slEff - entryEff; reward = entryEff - tpEff; }
                const ratio = risk > 0 && reward > 0 ? (reward / risk) : 0;
                const beWr = ratio > 0 ? (100 / (1 + ratio)) : null;
                const hist = simResult && !simResult.error && simResult.winRate ? parseFloat(simResult.winRate) : null;
                const wilson = simResult && !simResult.error && simResult.wilsonLower95 ? parseFloat(simResult.wilsonLower95) : 0;
                const edge = beWr != null && hist != null ? (hist - beWr) : null;
                const closedTrades = simResult && !simResult.error
                    ? Number(simResult.closedTrades != null ? simResult.closedTrades : (Number(simResult.wins || 0) + Number(simResult.losses || 0)))
                    : 0;
                const riskDistPercent = simResult && simResult.riskDistPercent != null ? parseFloat(simResult.riskDistPercent) : null;
                const avgMae = simResult && simResult.avgMae != null ? parseFloat(simResult.avgMae) : null;
                const maeRatio = riskDistPercent && riskDistPercent > 0 && avgMae != null
                    ? avgMae / riskDistPercent
                    : null;
                let auditState = null;

                if (simResult && !simResult.error) {
                    if (closedTrades < 30) {
                        auditState = 'INSUFFICIENTE';
                    } else if (riskDistPercent > 0 && maeRatio != null && maeRatio > 0.7) {
                        auditState = 'FRAGIL';
                    } else if (hist != null && beWr != null) {
                        if (hist < beWr) {
                            auditState = 'NEGATIVO';
                        } else if (wilson < beWr) {
                            auditState = 'ESPECULATIVO';
                        } else {
                            auditState = 'ROBUSTO';
                        }
                    }
                }

                let label = null;
                if (edge != null) {
                    if (edge >= 20) label = 'Excellent Trade';
                    else if (edge >= 10) label = 'Buen Trade';
                    else if (edge >= 0) label = 'Marginal';
                    else label = 'Esperanza Negativa';
                }

                return {
                    risk,
                    reward,

                    ratio,
                    beWr,
                    hist,
                    edge,
                    label,
                    wilson,
                    auditState,
                    maeRatio,
                    closedTrades
                };
            }, [entryPrice, stopLoss, takeProfit, tradeType, simResult, spread]);

            const auditVariant = useMemo(() => {
                if (!rrMetrics) return AUDIT_VARIANTS.DEFAULT;
                const key = rrMetrics.auditState || (rrMetrics.edge != null && rrMetrics.edge < 0 ? 'NEGATIVO' : 'DEFAULT');
                return AUDIT_VARIANTS[key] || AUDIT_VARIANTS.DEFAULT;
            }, [rrMetrics]);
            const AuditIcon = auditVariant.icon || Icons.Activity;

            const formatPrice = (value) => {
                const num = Number(value);
                if (!isFinite(num)) return '—';
                const abs = Math.abs(num);
                const decimals = abs >= 100 ? 2 : abs >= 1 ? 4 : 6;
                return num.toFixed(decimals);
            };

            const getMaePriceInfo = (maePct) => {
                const pct = Number(maePct);
                if (!isFinite(pct) || pct < 0) return null;
                const ep = Number(entryPrice);
                const sp = Math.max(0, Number(spread) || 0);
                if (!isFinite(ep) || ep <= 0 || !isFinite(sp)) return null;
                const half = sp / 2;
                const entryEff = tradeType === 'LONG' ? (ep + half) : (ep - half);
                if (!isFinite(entryEff) || entryEff <= 0) return null;
                const moveAbs = entryEff * (pct / 100);
                const level = tradeType === 'LONG' ? (entryEff - moveAbs) : (entryEff + moveAbs);
                if (!isFinite(level) || !isFinite(moveAbs)) return null;
                return {
                    entryEff,
                    level,
                    moveAbs
                };
            };

            const HealthChart = ({
                csvData,
                liveHistory,
                entryIndex,
                candlesSinceEntry,
                tfMinutes,
                simResult,
                tradeType,
                entryPrice,
                stopLoss,
                takeProfit,
                currentPrice,
                liveTradeStatus
            }) => {
                const containerRef = useRef(null);
                const chartRef = useRef(null);
                const resizeHandlerRef = useRef(null);

                useEffect(() => {
                    const container = containerRef.current;
                    if (!container) return;
                    if (!simResult) return;
                    if (liveTradeStatus && liveTradeStatus.status && liveTradeStatus.status !== 'ACTIVE') return;

                    const lc = window.LightweightCharts;
                    if (!lc || typeof lc.createChart !== 'function') {
                        container.innerHTML = '<div class="flex items-center justify-center h-full text-amber-600 dark:text-amber-400 p-4 text-center font-medium">Librería de gráficos no disponible. Verifica tu conexión a internet para cargar Lightweight Charts.</div>';
                        return;
                    }

                    const idx = Number(entryIndex);
                    if (!isFinite(idx) || idx < 0 || idx >= csvData.length) return;
                    const entryCandle = csvData[idx];
                    if (!entryCandle || !(entryCandle.datetime instanceof Date) || isNaN(entryCandle.datetime.getTime())) return;

                    if (chartRef.current) {
                        try { chartRef.current.remove(); } catch (e) { }
                        chartRef.current = null;
                    }
                    container.innerHTML = '';

                    const isDark = document.documentElement.classList.contains('dark');
                    const chart = lc.createChart(container, {
                        height: 400,
                        width: container.clientWidth || 800,
                        layout: {
                            background: { color: isDark ? '#0f172a' : '#ffffff' },
                            textColor: isDark ? '#cbd5e1' : '#0f172a'
                        },
                        grid: {
                            vertLines: { color: isDark ? 'rgba(148,163,184,0.12)' : 'rgba(15,23,42,0.08)' },
                            horzLines: { color: isDark ? 'rgba(148,163,184,0.12)' : 'rgba(15,23,42,0.08)' }
                        },
                        rightPriceScale: { borderVisible: false },
                        timeScale: { borderVisible: false, rightOffset: 6 },
                        crosshair: { mode: lc.CrosshairMode.Normal }
                    });
                    chartRef.current = chart;

                    const addCandles = (opts) => {
                        if (typeof chart.addCandlestickSeries === 'function') return chart.addCandlestickSeries(opts);
                        if (typeof chart.addSeries === 'function' && lc.CandlestickSeries) return chart.addSeries(lc.CandlestickSeries, opts);
                        return null;
                    };
                    const addLine = (opts) => {
                        if (typeof chart.addLineSeries === 'function') return chart.addLineSeries(opts);
                        if (typeof chart.addSeries === 'function' && lc.LineSeries) return chart.addSeries(lc.LineSeries, opts);
                        return null;
                    };

                    const candleSeries = addCandles({
                        upColor: '#16a34a',
                        downColor: '#dc2626',
                        borderUpColor: '#16a34a',
                        borderDownColor: '#dc2626',
                        wickUpColor: '#16a34a',
                        wickDownColor: '#dc2626'
                    });
                    if (!candleSeries) return;

                    const startIdx = Math.max(0, idx - 50);
                    const p80 = Number(simResult.p80Duration);
                    const post = isFinite(p80) ? Math.max(80, p80 + 20) : 120;
                    const endIdx = Math.min(csvData.length - 1, idx + post);
                    const slice = csvData.slice(startIdx, endIdx + 1);
                    const series = [];
                    for (let i = 0; i < slice.length; i++) {
                        const c = slice[i];
                        if (!c || !(c.datetime instanceof Date) || isNaN(c.datetime.getTime())) continue;
                        series.push({
                            time: Math.floor(c.datetime.getTime() / 1000),
                            open: Number(c.open),
                            high: Number(c.high),
                            low: Number(c.low),
                            close: Number(c.close)
                        });
                    }

                    const history = Array.isArray(liveHistory) ? liveHistory : [];
                    for (let i = 0; i < history.length; i++) {
                        const c = history[i];
                        if (!c || !(c.datetime instanceof Date) || isNaN(c.datetime.getTime())) continue;
                        series.push({
                            time: Math.floor(c.datetime.getTime() / 1000),
                            open: Number(c.open),
                            high: Number(c.high),
                            low: Number(c.low),
                            close: Number(c.close)
                        });
                    }

                    const timeMap = new Map();
                    for (let i = 0; i < series.length; i++) {
                        const b = series[i];
                        if (!b) continue;
                        if (!isFinite(b.time)) continue;
                        if (![b.open, b.high, b.low, b.close].every(x => isFinite(x))) continue;
                        timeMap.set(b.time, b);
                    }
                    const bars = Array.from(timeMap.values()).sort((a, b) => a.time - b.time);

                    if (!bars.length) return;
                    candleSeries.setData(bars);

                    // --- EMA 200 ---
                    const emaData = [];
                    const emaPeriod = 200;
                    if (bars.length >= emaPeriod) {
                        let sum = 0;
                        for (let i = 0; i < emaPeriod; i++) {
                            sum += bars[i].close;
                        }
                        let ema = sum / emaPeriod;
                        emaData.push({ time: bars[emaPeriod - 1].time, value: ema });
                        
                        const k = 2 / (emaPeriod + 1);
                        for (let i = emaPeriod; i < bars.length; i++) {
                            const price = bars[i].close;
                            ema = (price * k) + (ema * (1 - k));
                            emaData.push({ time: bars[i].time, value: ema });
                        }
                    }

                    if (emaData.length > 0) {
                        const emaSeries = addLine({
                            color: '#000000',
                            lineWidth: 1,
                            lineStyle: lc.LineStyle.Solid,
                            title: 'EMA 200',
                            crosshairMarkerVisible: false,
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                        if (emaSeries) emaSeries.setData(emaData);
                    }

                    const sl = Number(stopLoss);
                    const tp = Number(takeProfit);
                    const ep = Number(entryPrice);
                    const current = Number(currentPrice);
                    const since = Number(candlesSinceEntry);
                    const tfMin = Number(tfMinutes);

                    const adrTop = Number(entryCandle.adrRoomTop);
                    const adrBottom = Number(entryCandle.adrRoomBottom);
                    const maxMaeInfo = getMaePriceInfo(simResult.maxMae);
                    const avgMaeInfo = getMaePriceInfo(simResult.avgMae);

                    const rangeValues = [];
                    if (isFinite(sl)) rangeValues.push(sl);
                    if (isFinite(tp)) rangeValues.push(tp);
                    if (isFinite(ep)) rangeValues.push(ep);
                    if (isFinite(current) && current > 0) rangeValues.push(current);
                    if (isFinite(adrTop)) rangeValues.push(adrTop);
                    if (isFinite(adrBottom)) rangeValues.push(adrBottom);
                    if (maxMaeInfo && isFinite(maxMaeInfo.level)) rangeValues.push(Number(maxMaeInfo.level));
                    if (avgMaeInfo && isFinite(avgMaeInfo.level)) rangeValues.push(Number(avgMaeInfo.level));

                    const minBase = rangeValues.length ? Math.min(...rangeValues) : null;
                    const maxBase = rangeValues.length ? Math.max(...rangeValues) : null;
                    const pad = (minBase != null && maxBase != null) ? Math.max((maxBase - minBase) * 0.1, (maxBase || 1) * 0.002) : 0;
                    const rangeMin = minBase != null ? (minBase - pad) : null;
                    const rangeMax = maxBase != null ? (maxBase + pad) : null;

                    if (rangeMin != null && rangeMax != null && isFinite(rangeMin) && isFinite(rangeMax) && rangeMax > rangeMin) {
                        candleSeries.applyOptions({
                            autoscaleInfoProvider: () => ({
                                priceRange: { minValue: rangeMin, maxValue: rangeMax }
                            })
                        });
                    }

                    if (isFinite(ep)) {
                        candleSeries.createPriceLine({
                            price: ep,
                            color: '#2563eb',
                            lineWidth: 2,
                            lineStyle: lc.LineStyle.Solid,
                            axisLabelVisible: true,
                            title: 'Entry'
                        });
                    }
                    if (isFinite(tp)) {
                        candleSeries.createPriceLine({
                            price: tp,
                            color: '#16a34a',
                            lineWidth: 2,
                            lineStyle: lc.LineStyle.Solid,
                            axisLabelVisible: true,
                            title: 'TP'
                        });
                    }
                    if (isFinite(sl)) {
                        candleSeries.createPriceLine({
                            price: sl,
                            color: '#dc2626',
                            lineWidth: 2,
                            lineStyle: lc.LineStyle.Solid,
                            axisLabelVisible: true,
                            title: 'SL'
                        });
                    }

                    if (isFinite(adrTop)) {
                        candleSeries.createPriceLine({
                            price: adrTop,
                            color: isDark ? 'rgba(167,139,250,0.9)' : 'rgba(100,116,139,0.9)',
                            lineWidth: 1,
                            lineStyle: lc.LineStyle.Dashed,
                            axisLabelVisible: true,
                            title: 'ADR High'
                        });
                    }
                    if (isFinite(adrBottom)) {
                        candleSeries.createPriceLine({
                            price: adrBottom,
                            color: isDark ? 'rgba(167,139,250,0.9)' : 'rgba(100,116,139,0.9)',
                            lineWidth: 1,
                            lineStyle: lc.LineStyle.Dashed,
                            axisLabelVisible: true,
                            title: 'ADR Low'
                        });
                    }

                    if (maxMaeInfo && isFinite(maxMaeInfo.level)) {
                        candleSeries.createPriceLine({
                            price: maxMaeInfo.level,
                            color: '#ea580c',
                            lineWidth: 2,
                            lineStyle: lc.LineStyle.Solid,
                            axisLabelVisible: true,
                            title: 'Peor MAE Histórico'
                        });
                    }
                    if (avgMaeInfo && isFinite(avgMaeInfo.level)) {
                        candleSeries.createPriceLine({
                            price: avgMaeInfo.level,
                            color: '#fb923c',
                            lineWidth: 2,
                            lineStyle: lc.LineStyle.Dashed,
                            axisLabelVisible: true,
                            title: 'MAE Promedio'
                        });
                    }

                    const addVerticalHint = (tSec, color) => {
                        if (!isFinite(tSec) || tSec <= 0) return null;
                        if (rangeMin == null || rangeMax == null) return null;
                        const s = addLine({
                            color,
                            lineWidth: 2,
                            lineStyle: lc.LineStyle.Solid,
                            priceLineVisible: false,
                            lastValueVisible: false,
                            crosshairMarkerVisible: false
                        });
                        if (!s) return null;
                        s.setData([
                            { time: tSec - 1, value: rangeMin },
                            { time: tSec + 1, value: rangeMax }
                        ]);
                        return s;
                    };

                    const markers = [];
                    const entryTimeSec = Math.floor(entryCandle.datetime.getTime() / 1000);
                    markers.push({
                        time: entryTimeSec,
                        position: tradeType === 'LONG' ? 'belowBar' : 'aboveBar',
                        color: '#2563eb',
                        shape: tradeType === 'LONG' ? 'arrowUp' : 'arrowDown',
                        text: 'Entry'
                    });

                    const medianDur = Number(simResult.medianDuration);
                    const p80Dur = Number(simResult.p80Duration);
                    const tfSec = isFinite(tfMin) && tfMin > 0 ? tfMin * 60 : null;
                    if (tfSec) {
                        if (isFinite(medianDur) && medianDur > 0) {
                            const tMed = entryTimeSec + Math.round(medianDur * tfSec);
                            addVerticalHint(tMed, 'rgba(234,179,8,0.9)');
                            markers.push({
                                time: tMed,
                                position: 'aboveBar',
                                color: '#eab308',
                                shape: 'circle',
                                text: 'Fase de Decisión'
                            });
                        }
                        if (isFinite(p80Dur) && p80Dur > 0) {
                            const tP80 = entryTimeSec + Math.round(p80Dur * tfSec);
                            addVerticalHint(tP80, 'rgba(239,68,68,0.9)');
                            markers.push({
                                time: tP80,
                                position: 'aboveBar',
                                color: '#ef4444',
                                shape: 'circle',
                                text: 'Time Stop'
                            });
                        }
                    }

                    const lastBar = bars[bars.length - 1];
                    if (lastBar && isFinite(current) && current > 0) {
                        const ghost = addLine({
                            color: isDark ? 'rgba(148,163,184,0.9)' : 'rgba(71,85,105,0.9)',
                            lineWidth: 2,
                            lineStyle: lc.LineStyle.Dotted,
                            priceLineVisible: false,
                            lastValueVisible: false,
                            crosshairMarkerVisible: false
                        });
                        if (ghost) {
                            const projected = (tfSec && isFinite(since) && since >= 0) ? (entryTimeSec + Math.round(since * tfSec)) : Math.floor(Date.now() / 1000);
                            const nowSec = Math.max(projected, lastBar.time + 60);
                            ghost.setData([
                                { time: lastBar.time, value: lastBar.close },
                                { time: nowSec, value: current }
                            ]);
                            markers.push({
                                time: nowSec,
                                position: 'aboveBar',
                                color: isDark ? '#e2e8f0' : '#0f172a',
                                shape: 'circle',
                                text: 'Precio actual'
                            });
                        }
                    }

                    if (candleSeries && typeof candleSeries.setMarkers === 'function') {
                        candleSeries.setMarkers(markers);
                    }
                    chart.timeScale().fitContent();

                    const handleResize = () => {
                        const el = containerRef.current;
                        if (!el || !chartRef.current) return;
                        chartRef.current.applyOptions({ width: el.clientWidth || 800 });
                    };

                    if (resizeHandlerRef.current) {
                        window.removeEventListener('resize', resizeHandlerRef.current);
                        resizeHandlerRef.current = null;
                    }
                    resizeHandlerRef.current = handleResize;
                    window.addEventListener('resize', handleResize);

                    return () => {
                        if (resizeHandlerRef.current) {
                            window.removeEventListener('resize', resizeHandlerRef.current);
                            resizeHandlerRef.current = null;
                        }
                        if (chartRef.current) {
                            try { chartRef.current.remove(); } catch (e) { }
                            chartRef.current = null;
                        }
                    };
                }, [csvData, liveHistory, entryIndex, candlesSinceEntry, tfMinutes, simResult, tradeType, entryPrice, stopLoss, takeProfit, currentPrice, liveTradeStatus]);

                return (
                    <div
                        id="health-chart-container"
                        ref={containerRef}
                        className="bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 rounded-xl shadow-lg overflow-hidden"
                        style={{ height: '400px' }}
                    />
                );
            };

            // --- RENDERIZADO ---
            const tabClass = (tab) => `flex-1 py-4 text-center font-bold text-sm uppercase tracking-wider cursor-pointer transition-all border-b-2 ${activeTab === tab
                ? 'border-blue-500 text-blue-600 dark:text-blue-400 bg-blue-50 dark:bg-slate-800'
                : 'border-transparent text-slate-500 hover:text-slate-800 dark:hover:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-800/50'
                }`;
            const hasExtended = React.useMemo(() => {
                return csvData.some(d => d.volume !== undefined || d.buyPressurePct !== undefined || d.delta !== undefined);
            }, [csvData]);
            React.useEffect(() => {
                if (activeTab === 'SAVES') refreshSavedSims();
            }, [activeTab]);

            const autoTfConf = AUTOLOAD_TF_MAP[autoEntryTf] || { htf: null, ltf: null };
            const autoHtfTf = autoTfConf.htf;
            const autoLtfTf = autoTfConf.ltf;
            const autoRange = useMemo(() => buildAutoRange(autoStartDate, autoEndDate), [autoStartDate, autoEndDate]);
            const canStartAutoLoad = Boolean(
                autoSymbol &&
                autoEntryTf &&
                autoHtfTf &&
                autoLtfTf &&
                autoStartDate &&
                autoEndDate &&
                (autoMarket !== 'forex' || autoHasTwelveApiKey) &&
                autoRange &&
                autoRange.endMs > autoRange.startMs &&
                autoLoadPhase !== 'loading'
            );

            useEffect(() => {
                if (!isAutoLoadOpen) return;
                const onKeyDown = (e) => {
                    if (e.key === 'Escape' && autoLoadPhase !== 'loading') closeAutoLoad();
                };
                window.addEventListener('keydown', onKeyDown);
                return () => window.removeEventListener('keydown', onKeyDown);
            }, [isAutoLoadOpen, autoLoadPhase]);

            return (
                <div className="min-h-screen p-4 md:p-8">
                    {isAutoLoadOpen && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
                            <div
                                className="absolute inset-0 bg-slate-950/60"
                                onClick={() => {
                                    if (autoLoadPhase !== 'loading') closeAutoLoad();
                                }}
                            ></div>
                            <div className="relative w-full max-w-3xl bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 rounded-2xl shadow-2xl overflow-hidden">
                                <div className="p-5 border-b border-slate-200 dark:border-slate-800 flex items-start justify-between gap-4">
                                    <div>
                                        <div className="text-lg font-bold text-slate-800 dark:text-white">Carga automática ({autoMarket === 'forex' ? 'TwelveData' : 'Binance'})</div>
                                        <div className="text-xs text-slate-500 dark:text-slate-400 mt-1">Descarga y prepara 3 datasets (Entrada/HTF/LTF) incluyendo la vela en formación.</div>
                                    </div>
                                    <button
                                        type="button"
                                        disabled={autoLoadPhase === 'loading'}
                                        onClick={closeAutoLoad}
                                        className="px-3 py-2 rounded-lg text-sm font-bold bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-slate-600 dark:text-slate-200 disabled:opacity-50 disabled:cursor-not-allowed"
                                    >
                                        Cerrar
                                    </button>
                                </div>

                                <div className="p-5 space-y-4">
                                    {autoLoadError && (
                                        <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-900 rounded-lg p-3 text-sm text-red-700 dark:text-red-300">
                                            {autoLoadError}
                                        </div>
                                    )}

                                    {autoMarket === 'forex' && !autoHasTwelveApiKey && (
                                        <div className="bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-900 rounded-lg p-3 text-sm text-amber-800 dark:text-amber-200 flex items-center justify-between gap-3">
                                            <div>
                                                <div className="font-bold">Falta API Key de TwelveData</div>
                                                <div className="text-xs mt-0.5">Guárdala en Analizador de Mercado y vuelve aquí.</div>
                                            </div>
                                            <a href="/modulo-utilidades/analizador-mercado.html" target="_blank" rel="noreferrer" className="px-3 py-2 rounded-lg text-xs font-bold bg-white dark:bg-slate-800 border border-amber-200 dark:border-amber-700 text-amber-900 dark:text-amber-200 hover:bg-amber-100/60 dark:hover:bg-amber-900/30">
                                                Abrir analizador
                                            </a>
                                        </div>
                                    )}

                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                        <div className="bg-slate-50 dark:bg-slate-800/50 border border-slate-200 dark:border-slate-700 rounded-xl p-4">
                                            <div className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase mb-2">Mercado</div>
                                            <select value={autoMarket} onChange={(e) => setAutoMarket(e.target.value)} className="w-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded p-2 text-sm text-slate-900 dark:text-white">
                                                <option value="crypto">Cripto (Binance)</option>
                                                <option value="forex">Forex/Metales (TwelveData)</option>
                                            </select>
                                        </div>
                                        <div className="bg-slate-50 dark:bg-slate-800/50 border border-slate-200 dark:border-slate-700 rounded-xl p-4">
                                            <div className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase mb-2">Activo</div>
                                            <select value={autoSymbol} onChange={(e) => setAutoSymbol(e.target.value)} className="w-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded p-2 text-sm text-slate-900 dark:text-white">
                                                {(autoMarket === 'forex' ? FOREX_PAIRS : POPULAR_PAIRS).map((p) => (
                                                    <option key={p} value={p}>{p}</option>
                                                ))}
                                            </select>
                                        </div>

                                        <div className="bg-slate-50 dark:bg-slate-800/50 border border-slate-200 dark:border-slate-700 rounded-xl p-4">
                                            <div className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase mb-2">Temporalidad de entrada</div>
                                            <select value={autoEntryTf} onChange={(e) => setAutoEntryTf(e.target.value)} className="w-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded p-2 text-sm text-slate-900 dark:text-white">
                                                {AUTOLOAD_ENTRY_TFS.map((t) => (
                                                    <option key={t.interval} value={t.interval}>{t.label}</option>
                                                ))}
                                            </select>
                                            <div className="mt-2 grid grid-cols-2 gap-2 text-xs">
                                                <div className="bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 rounded-lg p-2">
                                                    <div className="text-[10px] text-slate-500">Temporalidad alta</div>
                                                    <div className="font-mono font-bold text-slate-800 dark:text-white">{AUTOLOAD_TF_LABEL[autoHtfTf] || '—'}</div>
                                                </div>
                                                <div className="bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 rounded-lg p-2">
                                                    <div className="text-[10px] text-slate-500">Temporalidad baja</div>
                                                    <div className="font-mono font-bold text-slate-800 dark:text-white">{AUTOLOAD_TF_LABEL[autoLtfTf] || '—'}</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div className="bg-slate-50 dark:bg-slate-800/50 border border-slate-200 dark:border-slate-700 rounded-xl p-4">
                                            <div className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase mb-2">Inicio</div>
                                            <input type="date" value={autoStartDate} onChange={(e) => setAutoStartDate(e.target.value)} className="w-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded p-2 text-sm text-slate-900 dark:text-white" />
                                        </div>
                                        <div className="bg-slate-50 dark:bg-slate-800/50 border border-slate-200 dark:border-slate-700 rounded-xl p-4">
                                            <div className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase mb-2">Fin</div>
                                            <input type="date" value={autoEndDate} onChange={(e) => setAutoEndDate(e.target.value)} className="w-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded p-2 text-sm text-slate-900 dark:text-white" />
                                            <div className="text-[11px] text-slate-500 dark:text-slate-400 mt-2">
                                                {autoRange && autoRange.endMs >= Date.now() - 30000 ? 'Fin efectivo: ahora (incluye vela en formación)' : 'Fin efectivo: cierre del día seleccionado'}
                                                {autoMarket === 'forex' ? ' · Forex excluye horas sin mercado (fines de semana/feriados)' : ''}
                                            </div>
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                                        {([
                                            { key: 'main', title: 'Principal', tf: AUTOLOAD_TF_LABEL[autoEntryTf] || autoEntryTf },
                                            { key: 'htf', title: 'HTF', tf: AUTOLOAD_TF_LABEL[autoHtfTf] || autoHtfTf },
                                            { key: 'ltf', title: 'LTF', tf: AUTOLOAD_TF_LABEL[autoLtfTf] || autoLtfTf }
                                        ]).map((x) => {
                                            const p = autoProgress[x.key];
                                            const pct = p && p.expected > 0 ? Math.min(100, Math.round((p.candles / p.expected) * 100)) : 0;
                                            const statusColor = p.status === 'done' ? 'text-green-600 dark:text-green-400' : p.status === 'loading' ? 'text-blue-600 dark:text-blue-400' : p.status === 'error' ? 'text-red-600 dark:text-red-400' : 'text-slate-500 dark:text-slate-400';
                                            return (
                                                <div key={x.key} className="bg-white dark:bg-slate-950 border border-slate-200 dark:border-slate-800 rounded-xl p-4">
                                                    <div className="flex items-center justify-between">
                                                        <div>
                                                            <div className="text-xs font-bold text-slate-600 dark:text-slate-300">{x.title}</div>
                                                            <div className="text-[11px] text-slate-500 dark:text-slate-400 font-mono">{x.tf || '—'}</div>
                                                        </div>
                                                        <div className={`text-xs font-bold ${statusColor}`}>{p.status === 'done' ? 'OK' : p.status === 'loading' ? 'Cargando' : p.status === 'error' ? 'Error' : 'Listo'}</div>
                                                    </div>
                                                    <div className="mt-3 h-2 bg-slate-200 dark:bg-slate-800 rounded-full overflow-hidden">
                                                        <div className="h-full bg-blue-600" style={{ width: `${pct}%` }}></div>
                                                    </div>
                                                    <div className="mt-2 flex justify-between text-[10px] text-slate-500 dark:text-slate-400 font-mono">
                                                        <span>{p.candles}/{p.expected || '—'}</span>
                                                        <span>{p.calls} req</span>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>

                                    <div className="flex items-center justify-end gap-3 pt-2">
                                        <button
                                            type="button"
                                            onClick={() => {
                                                setAutoLoadError(null);
                                                if (canStartAutoLoad) startAutoLoad();
                                            }}
                                            disabled={!canStartAutoLoad}
                                            className="bg-blue-600 hover:bg-blue-500 disabled:bg-slate-400 disabled:cursor-not-allowed text-white font-bold px-5 py-2 rounded-lg shadow-lg transition-all active:scale-95 disabled:active:scale-100"
                                        >
                                            {autoLoadPhase === 'loading' ? 'Descargando…' : autoLoadPhase === 'success' ? 'Completado' : 'Iniciar descarga'}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                    {/* MODAL DE DISTRIBUCIÓN DE DURACIÓN */}
                    {isDurationModalOpen && simResult && !simResult.error && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
                            <div
                                className="absolute inset-0 bg-slate-950/60"
                                onClick={() => setIsDurationModalOpen(false)}
                            ></div>
                            <div className="relative w-full max-w-2xl max-h-[90vh] bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 rounded-2xl shadow-2xl overflow-hidden flex flex-col">
                                <div className="p-5 border-b border-slate-200 dark:border-slate-800 flex items-start justify-between gap-4">
                                    <div>
                                        <div className="text-lg font-bold text-slate-800 dark:text-white flex items-center gap-2">
                                            <Icons.Clock size={20} className="text-blue-500" /> Distribución de Duración
                                        </div>
                                        <div className="text-xs text-slate-500 dark:text-slate-400 mt-1">Análisis detallado de cuántas velas tardan los trades ganadores en cerrar.</div>
                                    </div>
                                    <button
                                        type="button"
                                        onClick={() => setIsDurationModalOpen(false)}
                                        className="px-3 py-2 rounded-lg text-sm font-bold bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-slate-600 dark:text-slate-200"
                                    >
                                        Cerrar
                                    </button>
                                </div>

                                <div className="p-5 space-y-5 overflow-y-auto">
                                    {/* MÉTRICAS CLAVE */}
                                    <div className="grid grid-cols-5 gap-2 text-center">
                                        <div className="bg-slate-50 dark:bg-slate-800 p-3 rounded-lg">
                                            <div className="text-[10px] text-slate-400 uppercase">Min</div>
                                            <div className="font-mono font-bold text-lg text-slate-700 dark:text-slate-200">{simResult.minDuration}</div>
                                        </div>
                                        <div className="bg-green-50 dark:bg-green-900/20 p-3 rounded-lg border border-green-200 dark:border-green-800">
                                            <div className="text-[10px] text-green-600 dark:text-green-400 uppercase">Mediana</div>
                                            <div className="font-mono font-bold text-lg text-green-600 dark:text-green-400">{simResult.medianDuration}</div>
                                        </div>
                                        <div className="bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg border border-blue-200 dark:border-blue-800">
                                            <div className="text-[10px] text-blue-600 dark:text-blue-400 uppercase">Media</div>
                                            <div className="font-mono font-bold text-lg text-blue-600 dark:text-blue-400">{simResult.avgDuration}</div>
                                        </div>
                                        <div className="bg-orange-50 dark:bg-orange-900/20 p-3 rounded-lg border border-orange-200 dark:border-orange-800">
                                            <div className="text-[10px] text-orange-600 dark:text-orange-400 uppercase">P80</div>
                                            <div className="font-mono font-bold text-lg text-orange-600 dark:text-orange-400">{simResult.p80Duration}</div>
                                        </div>
                                        <div className="bg-slate-50 dark:bg-slate-800 p-3 rounded-lg">
                                            <div className="text-[10px] text-slate-400 uppercase">Max</div>
                                            <div className="font-mono font-bold text-lg text-slate-700 dark:text-slate-200">{simResult.maxDuration}</div>
                                        </div>
                                    </div>

                                    {/* HISTOGRAMA / DISTRIBUCIÓN */}
                                    <div className="bg-slate-50 dark:bg-slate-800 p-4 rounded-xl border border-slate-200 dark:border-slate-700">
                                        <div className="text-xs font-bold text-slate-600 dark:text-slate-300 uppercase mb-3">Histograma de Duraciones</div>
                                        <div className="space-y-1 max-h-60 overflow-y-auto">
                                            {(() => {
                                                const dist = simResult.durationDistribution || {};
                                                const entries = Object.entries(dist).map(([k, v]) => [parseInt(k), v]).sort((a, b) => a[0] - b[0]);
                                                const maxCount = Math.max(...entries.map(e => e[1]), 1);
                                                const totalWins = simResult.wins || 1;
                                                if (entries.length === 0) return <div className="text-sm text-slate-500 italic">Sin datos de distribución.</div>;
                                                return entries.map(([dur, count]) => {
                                                    const pct = ((count / totalWins) * 100).toFixed(1);
                                                    const barWidth = (count / maxCount) * 100;
                                                    const isMedian = dur === simResult.medianDuration;
                                                    const isP80 = dur === simResult.p80Duration;
                                                    return (
                                                        <div key={dur} className="flex items-center gap-2 text-xs">
                                                            <div className="w-12 text-right font-mono text-slate-600 dark:text-slate-300">{dur} <span className="text-[9px] text-slate-400">v</span></div>
                                                            <div className="flex-1 h-5 bg-slate-200 dark:bg-slate-700 rounded-sm overflow-hidden relative">
                                                                <div
                                                                    className={`h-full rounded-sm transition-all ${isP80 ? 'bg-orange-500' : isMedian ? 'bg-green-500' : 'bg-blue-500'}`}
                                                                    style={{ width: barWidth + '%' }}
                                                                ></div>
                                                            </div>
                                                            <div className="w-16 text-right font-mono">
                                                                <span className="text-slate-700 dark:text-slate-200">{count}</span>
                                                                <span className="text-slate-400 ml-1">({pct}%)</span>
                                                            </div>
                                                            {isMedian && <span className="text-[9px] bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300 px-1 rounded">Mediana</span>}
                                                            {isP80 && <span className="text-[9px] bg-orange-100 dark:bg-orange-900 text-orange-700 dark:text-orange-300 px-1 rounded">P80</span>}
                                                        </div>
                                                    );
                                                });
                                            })()}
                                        </div>
                                    </div>

                                    {/* GUÍA ESTRATÉGICA */}
                                    <div className="bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-slate-800 dark:to-slate-800 p-4 rounded-xl border border-blue-200 dark:border-indigo-900">
                                        <div className="text-xs font-bold text-indigo-700 dark:text-indigo-400 uppercase mb-2 flex items-center gap-2">
                                            <Icons.ShieldAlert size={14} /> Guía para Break Even (Time Stop)
                                        </div>
                                        <div className="space-y-2 text-xs text-slate-700 dark:text-slate-300">
                                            <div className="flex items-start gap-2">
                                                <span className="inline-block w-3 h-3 rounded-full bg-green-500 mt-0.5 shrink-0"></span>
                                                <div><b>Fase Temprana ({"<"} {simResult.medianDuration} velas):</b> Todo normal. Deja correr el trade.</div>
                                            </div>
                                            <div className="flex items-start gap-2">
                                                <span className="inline-block w-3 h-3 rounded-full bg-yellow-500 mt-0.5 shrink-0"></span>
                                                <div><b>Fase de Decisión ({simResult.medianDuration}-{simResult.p80Duration} velas):</b> El trade tarda más de lo habitual. Considera BE si hay eventos cercanos.</div>
                                            </div>
                                            <div className="flex items-start gap-2">
                                                <span className="inline-block w-3 h-3 rounded-full bg-red-500 mt-0.5 shrink-0"></span>
                                                <div><b>Time Stop ({">"} {simResult.p80Duration} velas):</b> El 80% de los ganadores ya cerraron. Mover a BE obligatorio o evaluar cierre.</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                    <div className="max-w-6xl mx-auto bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 rounded-2xl shadow-2xl overflow-hidden transition-colors duration-300">

                        {/* HEADER */}
                        <div className="bg-slate-50 dark:bg-slate-950 p-6 border-b border-slate-200 dark:border-slate-800 flex justify-between items-center transition-colors duration-300">
                            <div>
                                <h1 className="text-2xl font-bold text-blue-600 dark:text-blue-500 flex items-center gap-2">
                                    <Icons.Activity className="text-blue-600 dark:text-blue-500" /> Smart Trading Suite
                                </h1>
                                <p className="text-slate-500 dark:text-slate-500 text-sm mt-1">Probabilidad Histórica & Gestión Activa</p>
                            </div>
                            <div className="flex items-center gap-3">
                                {csvData.length > 0 && (
                                    <div className="hidden md:flex items-center gap-2 bg-white dark:bg-slate-900 px-3 py-1 rounded-full border border-slate-200 dark:border-slate-800 text-xs text-green-600 dark:text-green-400 shadow-sm">
                                        <Icons.CheckCircle size={12} /> Dataset Cargado ({csvData.length} velas)
                                    </div>
                                )}
                                <button
                                    onClick={handleClearCurrentSession}
                                    className="bg-white dark:bg-slate-800 hover:bg-red-50 dark:hover:bg-red-950/30 text-slate-400 hover:text-red-500 p-2 rounded-lg border border-slate-200 dark:border-slate-700 transition-all hover:border-red-200 dark:hover:border-red-900 shadow-sm"
                                    title="Limpiar sesión actual"
                                >
                                    <Icons.Trash2 size={18} />
                                </button>
                                <a href="/utilidades.html" className="bg-white dark:bg-slate-800 hover:bg-slate-100 dark:hover:bg-slate-700 text-slate-600 dark:text-slate-300 px-4 py-2 rounded-lg text-sm font-medium border border-slate-200 dark:border-slate-700 flex items-center gap-2 transition-all hover:border-slate-300 dark:hover:border-slate-600 shadow-sm">
                                    <Icons.History size={16} />
                                    Volver a Utilidades
                                </a>
                            </div>
                        </div>

                        {/* NAV TABS */}
                        <div className="flex border-b border-slate-200 dark:border-slate-800 bg-slate-50 dark:bg-slate-950">
                            <div className={tabClass('LAB')} onClick={() => setActiveTab('LAB')}>
                                1. Laboratorio (Backtest)
                            </div>
                            <div className={tabClass('MONITOR')} onClick={() => {
                                if (!simResult) alert("Primero ejecuta una simulación en el Laboratorio para generar datos de referencia.");
                                else setActiveTab('MONITOR');
                            }}>
                                2. Monitor (Gestión)
                            </div>
                            <div className={tabClass('SAVES')} onClick={() => setActiveTab('SAVES')}>
                                3. Guardadas
                            </div>
                        </div>

                        {/* CONTENIDO PRINCIPAL */}
                        <div className="p-6 md:p-8 min-h-[600px]">

                            {/* --- PESTAÑA 1: LABORATORIO --- */}
                            {activeTab === 'LAB' && (
                                <div className="grid grid-cols-1 lg:grid-cols-12 gap-8 animate-fade-in">

                                    {/* COLUMNA IZQUIERDA: CONFIGURACION */}
                                    <div id="analysis-config" className="lg:col-span-5 space-y-6">

                                        {/* 1. DATASET */}
                                        <section
                                            className={`bg-slate-50 dark:bg-slate-800/50 p-5 rounded-xl border transition-all duration-300 ${isDragging ? 'border-blue-500 ring-2 ring-blue-500/20 bg-blue-50/50 dark:bg-slate-800' : 'border-slate-200 dark:border-slate-700/50'} shadow-sm`}
                                            onDragOver={handleDragOver}
                                            onDragLeave={handleDragLeave}
                                            onDrop={handleDrop}
                                        >
                                            <div className="flex items-center justify-between gap-3 mb-3">
                                                <h3 className="text-sm font-bold text-slate-500 dark:text-slate-400 uppercase flex items-center gap-2"><Icons.Upload size={16} /> Data Source</h3>
                                                <button
                                                    type="button"
                                                    onClick={openAutoLoad}
                                                    className="bg-blue-600 hover:bg-blue-500 text-white text-xs font-bold px-3 py-2 rounded-lg shadow-sm transition-all active:scale-95"
                                                >
                                                    Carga automática
                                                </button>
                                            </div>

                                            {csvData.length > 0 && fileName ? (
                                                <div className="relative group w-full animate-fade-in">
                                                    <input
                                                        type="file"
                                                        accept=".csv"
                                                        onChange={handleFileUpload}
                                                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20"
                                                        title="Clic para cambiar archivo"
                                                    />
                                                    <div className="border border-green-200 dark:border-green-900 bg-green-50 dark:bg-green-900/20 rounded-lg p-4 flex items-center justify-between transition-colors group-hover:bg-green-100 dark:group-hover:bg-green-900/30">
                                                        <div className="flex items-center gap-3 overflow-hidden">
                                                            <div className="p-2 bg-green-100 dark:bg-green-800 rounded-lg text-green-600 dark:text-green-300 shrink-0">
                                                                <Icons.FileText size={20} />
                                                            </div>
                                                            <div className="min-w-0">
                                                                <p className="text-sm font-bold text-slate-800 dark:text-slate-200 truncate pr-2">{fileName}</p>
                                                                <p className="text-xs text-green-600 dark:text-green-400 flex items-center gap-1">
                                                                    <Icons.CheckCircle size={12} /> Cargado correctamente
                                                                </p>
                                                            </div>
                                                        </div>
                                                        <div className="text-xs text-slate-400 dark:text-slate-500 font-mono bg-white dark:bg-slate-950 px-2 py-1 rounded border border-slate-200 dark:border-slate-800">
                                                            {csvData.length} velas
                                                        </div>
                                                    </div>
                                                </div>
                                            ) : fileError ? (
                                                <div className="relative group w-full animate-fade-in">
                                                    <input
                                                        type="file"
                                                        accept=".csv"
                                                        onChange={handleFileUpload}
                                                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20"
                                                        title="Clic para intentar de nuevo"
                                                    />
                                                    <div className="border border-red-200 dark:border-red-900 bg-red-50 dark:bg-red-900/20 rounded-lg p-4 flex items-center justify-between transition-colors group-hover:bg-red-100 dark:group-hover:bg-red-900/30">
                                                        <div className="flex items-center gap-3 overflow-hidden">
                                                            <div className="p-2 bg-red-100 dark:bg-red-800 rounded-lg text-red-600 dark:text-red-300 shrink-0">
                                                                <Icons.AlertCircle size={20} />
                                                            </div>
                                                            <div className="min-w-0">
                                                                <p className="text-sm font-bold text-slate-800 dark:text-slate-200 truncate pr-2">{fileName || 'Archivo inválido'}</p>
                                                                <p className="text-xs text-red-600 dark:text-red-400 flex items-center gap-1">
                                                                    {fileError}
                                                                </p>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            ) : (
                                                <div className="relative group w-full">
                                                    <input
                                                        type="file"
                                                        accept=".csv"
                                                        onChange={handleFileUpload}
                                                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20"
                                                        title=""
                                                    />
                                                    <div className={`border-2 border-dashed rounded-lg p-6 flex flex-col items-center justify-center text-center transition-all duration-300 ${isDragging ? 'border-blue-500 bg-blue-100/10' : 'border-slate-300 dark:border-slate-600 group-hover:border-blue-400 dark:group-hover:border-blue-500 bg-slate-50 dark:bg-slate-900/50'}`}>
                                                        <div className={`p-3 rounded-full bg-slate-100 dark:bg-slate-800 mb-3 transition-transform duration-300 ${isDragging ? 'scale-110 text-blue-600' : 'text-slate-400 group-hover:text-blue-500'}`}>
                                                            <Icons.Upload size={24} />
                                                        </div>
                                                        <p className="text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">
                                                            {isDragging ? '¡Suelta el archivo CSV aquí!' : 'Haz clic o arrastra tu archivo CSV'}
                                                        </p>
                                                        <p className="text-xs text-slate-400 dark:text-slate-500">
                                                            Soporta formato OHLC estándar y extendido
                                                        </p>
                                                    </div>
                                                </div>
                                            )}

                                            <div className="mt-4 grid grid-cols-1 md:grid-cols-2 gap-3">
                                                <div className="bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 rounded-lg p-4 relative overflow-hidden">
                                                    <div className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase mb-2">HTF (Mapa)</div>
                                                    <input type="file" accept=".csv" onChange={(e) => processHtfFile(e.target.files[0])} className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" title="Cargar CSV HTF" />
                                                    {htfData.length > 0 && htfFileName ? (
                                                        <div className="flex items-center justify-between gap-3">
                                                            <div className="min-w-0">
                                                                <div className="text-sm font-bold text-slate-800 dark:text-slate-200 truncate">{htfFileName}</div>
                                                                <div className="text-[11px] text-slate-500 dark:text-slate-400">{htfData.length} velas · {htfTfMinutes ? `${htfTfMinutes}m` : '—'}</div>
                                                            </div>
                                                            <div className="text-xs text-green-600 dark:text-green-400 font-bold">OK</div>
                                                        </div>
                                                    ) : htfError ? (
                                                        <div className="text-sm text-red-600 dark:text-red-400 font-medium">{htfError}</div>
                                                    ) : (
                                                        <div className="text-sm text-slate-500 dark:text-slate-400">Clic para cargar HTF</div>
                                                    )}
                                                </div>

                                                <div className="bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 rounded-lg p-4 relative overflow-hidden">
                                                    <div className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase mb-2">LTF (Microscopio)</div>
                                                    <input type="file" accept=".csv" onChange={(e) => processLtfFile(e.target.files[0])} className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" title="Cargar CSV LTF" />
                                                    {ltfData.length > 0 && ltfFileName ? (
                                                        <div className="flex items-center justify-between gap-3">
                                                            <div className="min-w-0">
                                                                <div className="text-sm font-bold text-slate-800 dark:text-slate-200 truncate">{ltfFileName}</div>
                                                                <div className="text-[11px] text-slate-500 dark:text-slate-400">{ltfData.length} velas · {ltfTfMinutes ? `${ltfTfMinutes}m` : '—'}</div>
                                                            </div>
                                                            <div className="text-xs text-green-600 dark:text-green-400 font-bold">OK</div>
                                                        </div>
                                                    ) : ltfError ? (
                                                        <div className="text-sm text-red-600 dark:text-red-400 font-medium">{ltfError}</div>
                                                    ) : (
                                                        <div className="text-sm text-slate-500 dark:text-slate-400">Clic para cargar LTF</div>
                                                    )}
                                                </div>
                                            </div>

                                            <div className="mt-3 bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 rounded-lg p-4">
                                                <div className="flex items-center justify-between">
                                                    <div className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase">Límite memoria LTF</div>
                                                    <div className="text-xs text-slate-500 dark:text-slate-400 font-mono">{ltfMaxCandles}</div>
                                                </div>
                                                <input type="range" min="5000" max="120000" step="5000" value={ltfMaxCandles} onChange={(e) => setLtfMaxCandles(parseInt(e.target.value))} className="w-full accent-blue-500 h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer mt-2" />
                                                <div className="text-[11px] text-slate-500 dark:text-slate-400 mt-1">Se recorta el histórico LTF más antiguo si supera el límite.</div>
                                            </div>
                                        </section>

                                        {/* 2. ESCENARIO */}
                                        <section className="bg-slate-50 dark:bg-slate-800/50 p-5 rounded-xl border border-slate-200 dark:border-slate-700/50 shadow-sm">
                                            <h3 className="text-sm font-bold text-slate-500 dark:text-slate-400 uppercase mb-3 flex items-center gap-2"><Icons.History size={16} /> Escenario (Vela Actual)</h3>
                                            {csvData.length > 0 ? (
                                                <>
                                                    <div className="flex items-center gap-2">
                                                        <button
                                                            type="button"
                                                            onClick={() => setSelectedCandleIndex((prev) => Math.max(200, prev - 1))}
                                                            disabled={selectedCandleIndex <= 200}
                                                            aria-label="Vela anterior"
                                                            className="h-10 w-10 shrink-0 inline-flex items-center justify-center bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded-lg text-slate-700 dark:text-slate-200 hover:bg-slate-50 dark:hover:bg-slate-800 active:scale-95 transition disabled:opacity-40 disabled:cursor-not-allowed"
                                                        >
                                                            <Icons.ChevronLeft size={18} />
                                                        </button>
                                                        <input
                                                            type="range"
                                                            min="200"
                                                            max={csvData.length - 1}
                                                            value={selectedCandleIndex}
                                                            onChange={(e) => setSelectedCandleIndex(parseInt(e.target.value, 10))}
                                                            className="flex-1 accent-blue-500 h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer"
                                                        />
                                                        <button
                                                            type="button"
                                                            onClick={() => setSelectedCandleIndex((prev) => Math.min(csvData.length - 1, prev + 1))}
                                                            disabled={selectedCandleIndex >= csvData.length - 1}
                                                            aria-label="Vela siguiente"
                                                            className="h-10 w-10 shrink-0 inline-flex items-center justify-center bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded-lg text-slate-700 dark:text-slate-200 hover:bg-slate-50 dark:hover:bg-slate-800 active:scale-95 transition disabled:opacity-40 disabled:cursor-not-allowed"
                                                        >
                                                            <Icons.ChevronRight size={18} />
                                                        </button>
                                                    </div>
                                                    <div className="mt-3 grid grid-cols-1 md:grid-cols-3 gap-3 text-xs font-mono">
                                                        <div className="bg-white dark:bg-slate-900 p-2 rounded border border-slate-200 dark:border-slate-800">
                                                            <div className="text-[11px] text-slate-500">Índice en dataset</div>
                                                            <div className="text-slate-800 dark:text-white font-bold">{selectedCandleIndex}</div>
                                                        </div>
                                                        <div className="bg-white dark:bg-slate-900 p-2 rounded border border-slate-200 dark:border-slate-800">
                                                            <div className="text-[11px] text-slate-500">Fecha</div>
                                                            <div className="text-blue-600 dark:text-blue-300 font-bold">
                                                                {(csvData[selectedCandleIndex] && csvData[selectedCandleIndex].datetime) ? csvData[selectedCandleIndex].datetime.toLocaleDateString('es-ES') : '—'}
                                                                {' '}
                                                                {(csvData[selectedCandleIndex] && csvData[selectedCandleIndex].datetime) ? csvData[selectedCandleIndex].datetime.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }) : ''}
                                                            </div>
                                                        </div>
                                                        <div className="bg-white dark:bg-slate-900 p-2 rounded border border-slate-200 dark:border-slate-800">
                                                            <div className="text-[11px] text-slate-500">Periodo de la vela</div>
                                                            <div className="text-slate-800 dark:text-white font-bold">
                                                                {(() => {
                                                                    const d = csvData[selectedCandleIndex] ? csvData[selectedCandleIndex].datetime : undefined;
                                                                    const tf = tfMinutes || 0;
                                                                    if (!d || !tf) return '—';
                                                                    const end = new Date(d.getTime() + tf * 60000);
                                                                    const fmt = (x) => x.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
                                                                    const tfLabel = tf >= 1440 ? `${Math.round(tf / 1440)}D` : tf >= 60 ? `${Math.round(tf / 60)}H` : `${tf}m`;
                                                                    return `${fmt(d)} → ${fmt(end)} (${tfLabel})`;
                                                                })()}
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <div className="mt-4 grid grid-cols-2 gap-4 text-sm font-mono">
                                                        <div className="bg-white dark:bg-slate-900 p-2 rounded border border-slate-200 dark:border-slate-800">
                                                            <div className="text-xs text-slate-500">Precio Cierre</div>
                                                            <div className="text-blue-600 dark:text-blue-300 font-bold">{entryPrice.toFixed(2)}</div>
                                                        </div>
                                                        <div className="bg-white dark:bg-slate-900 p-2 rounded border border-slate-200 dark:border-slate-800">
                                                            <div className="text-xs text-slate-500">RSI (14)</div>
                                                            <div className={targetRsi > 70 ? 'text-red-500 dark:text-red-400' : targetRsi < 30 ? 'text-green-600 dark:text-green-400' : 'text-slate-700 dark:text-slate-300'}>{targetRsi}</div>
                                                        </div>
                                                    </div>

                                                    {/* --- Indicador ADR (Average Daily Range) --- */}
                                                    {(() => {
                                                        const candle = csvData[selectedCandleIndex];
                                                        if (!candle || candle.adrValue == null) return null;
                                                        const adrPct = candle.adrFilledPct || 0;
                                                        const isExhausted = adrPct > 100;
                                                        const barWidth = Math.min(adrPct, 150); // Cap visual al 150%
                                                        return (
                                                            <div className={`mt-4 p-3 rounded-lg border shadow-sm ${isExhausted ? 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800' : 'bg-white dark:bg-slate-900 border-slate-200 dark:border-slate-800'}`}>
                                                                <div className="flex items-center justify-between mb-2">
                                                                    <div className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase flex items-center gap-2">
                                                                        <Icons.Activity size={12} /> ADR Diario (14D)
                                                                    </div>
                                                                    {isExhausted && (
                                                                        <span className="text-[10px] font-bold text-red-600 dark:text-red-400 bg-red-100 dark:bg-red-900/30 px-2 py-0.5 rounded animate-pulse">
                                                                            ⚠️ AGOTAMIENTO ESTADÍSTICO
                                                                        </span>
                                                                    )}
                                                                </div>
                                                                <div className="grid grid-cols-2 gap-3 text-xs font-mono mb-2">
                                                                    <div>
                                                                        <div className="text-[10px] text-slate-500">Rango Hoy</div>
                                                                        <div className="text-slate-800 dark:text-white font-bold">{candle.currentDayRange != null ? candle.currentDayRange.toFixed(2) : '—'}</div>
                                                                    </div>
                                                                    <div>
                                                                        <div className="text-[10px] text-slate-500">ADR Promedio</div>
                                                                        <div className="text-blue-600 dark:text-blue-300 font-bold">{candle.adrValue != null ? candle.adrValue.toFixed(2) : '—'}</div>
                                                                    </div>
                                                                </div>
                                                                {/* Barra de Progreso ADR */}
                                                                <div className="relative h-3 bg-slate-200 dark:bg-slate-700 rounded-full overflow-hidden">
                                                                    <div
                                                                        className={`h-full transition-all duration-300 ${isExhausted ? 'bg-red-500' : adrPct > 80 ? 'bg-orange-500' : 'bg-green-500'}`}
                                                                        style={{ width: `${Math.min(barWidth, 100)}%` }}
                                                                    ></div>
                                                                    {adrPct > 100 && (
                                                                        <div
                                                                            className="absolute top-0 h-full bg-red-600/50"
                                                                            style={{ left: '100%', width: `${Math.min(adrPct - 100, 50)}%` }}
                                                                        ></div>
                                                                    )}
                                                                    {/* Marcador del 100% */}
                                                                    <div className="absolute top-0 bottom-0 w-0.5 bg-slate-400 dark:bg-slate-500" style={{ left: '100%' }}></div>
                                                                </div>
                                                                <div className="flex justify-between text-[10px] text-slate-500 mt-1">
                                                                    <span>0%</span>
                                                                    <span className={`font-bold ${isExhausted ? 'text-red-600 dark:text-red-400' : 'text-slate-700 dark:text-slate-300'}`}>
                                                                        {adrPct.toFixed(1)}% Completado
                                                                    </span>
                                                                    <span>100%</span>
                                                                </div>
                                                            </div>
                                                        );
                                                    })()}
                                                </>

                                            ) : <div className="text-slate-500 dark:text-slate-600 text-sm italic">Carga un archivo CSV primero...</div>}
                                        </section>

                                        {/* 3. ESTRATEGIA */}
                                        <section className="bg-slate-50 dark:bg-slate-800/50 p-5 rounded-xl border border-slate-200 dark:border-slate-700/50 shadow-sm">
                                            <h3 className="text-sm font-bold text-slate-500 dark:text-slate-400 uppercase mb-3 flex items-center gap-2"><Icons.TrendingUp size={16} /> Estrategia de Trade</h3>
                                            <div className="flex bg-slate-200 dark:bg-slate-900 p-1 rounded-lg mb-4">
                                                <button onClick={() => setTradeType('LONG')} className={`flex-1 py-2 rounded text-xs font-bold transition-all ${tradeType === 'LONG' ? 'bg-green-600 text-white shadow-md' : 'text-slate-500 hover:text-slate-700 dark:hover:text-slate-300'}`}>LONG</button>
                                                <button onClick={() => setTradeType('SHORT')} className={`flex-1 py-2 rounded text-xs font-bold transition-all ${tradeType === 'SHORT' ? 'bg-red-600 text-white shadow-md' : 'text-slate-500 hover:text-slate-700 dark:hover:text-slate-300'}`}>SHORT</button>
                                            </div>
                                            <div className="grid grid-cols-2 gap-3">
                                                <div>
                                                    <label className="text-xs text-red-500 dark:text-red-400 font-bold">Stop Loss</label>
                                                    <input type="number" placeholder="Precio SL" value={stopLoss} onChange={(e) => setStopLoss(e.target.value)} className="w-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded p-2 text-sm font-mono leading-tight mt-1 text-slate-900 dark:text-white focus:border-red-500 outline-none transition-colors" />
                                                </div>
                                                <div>
                                                    <label className="text-xs text-green-600 dark:text-green-400 font-bold">Take Profit</label>
                                                    <input type="number" placeholder="Precio TP" value={takeProfit} onChange={(e) => setTakeProfit(e.target.value)} className="w-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded p-2 text-sm font-mono leading-tight mt-1 text-slate-900 dark:text-white focus:border-green-500 outline-none transition-colors" />
                                                </div>
                                            </div>
                                            <div className="mt-3">
                                                <label className="text-xs text-slate-600 dark:text-slate-300 font-bold">Spread (puntos)</label>
                                                <input type="number" min="0" step="0.01" placeholder="0" value={spread} onChange={(e) => setSpread(e.target.value)} className="w-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded p-2 text-sm font-mono leading-tight mt-1 text-slate-900 dark:text-white focus:border-blue-500 outline-none transition-colors" />
                                            </div>
                                            <button onClick={handleAutoDetect} disabled={!csvData.length || isAutoDetecting} className="w-full mt-3 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-400 disabled:cursor-not-allowed disabled:hover:bg-slate-400 text-white font-bold py-2 rounded-lg shadow-lg flex items-center justify-center gap-2 transition-all active:scale-95 disabled:active:scale-100">
                                                {isAutoDetecting ? <Icons.Activity size={16} className="animate-spin" /> : <Icons.Target size={16} />} AUTO-DETECTAR SETUP
                                            </button>

                                            <details className="group mt-3 border border-slate-200 dark:border-slate-800 rounded overflow-hidden">
                                                <summary className="flex items-center justify-between p-2 cursor-pointer bg-slate-50 dark:bg-slate-900 text-xs font-bold text-slate-500 hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors select-none">
                                                    <span className="flex items-center gap-2"><Icons.Zap size={12} /> ¿Cómo funciona la Auto-Detección?</span>
                                                    <Icons.ChevronDown size={12} className="transition-transform group-open:rotate-180" />
                                                </summary>
                                                <div className="p-3 bg-white dark:bg-slate-950 text-[10px] space-y-2 border-t border-slate-200 dark:border-slate-800 text-slate-600 dark:text-slate-400">
                                                    <p><strong className="text-slate-700 dark:text-slate-300">1. Análisis de Volatilidad:</strong> Se calcula el ATR (14 periodos) para medir el "ruido" del mercado y adaptar el SL dinámicamente.</p>
                                                    <p><strong className="text-slate-700 dark:text-slate-300">2. Estructura de Mercado:</strong> Se identifican los Swing Highs y Lows más recientes para anclar el SL en niveles técnicos lógicos.</p>
                                                    <p><strong className="text-slate-700 dark:text-slate-300">3. Generación de Candidatos:</strong> El sistema prueba múltiples combinaciones de SL (Estructural vs ATR) y TP (Ratios 1:1 a 1:5).</p>
                                                    <p><strong className="text-slate-700 dark:text-slate-300">4. Validación Estadística:</strong> Se ejecuta un Backtest rápido para cada candidato. Solo se sugiere el que tenga &gt;30 trades históricos y Esperanza Matemática (Edge) positiva.</p>
                                                </div>
                                            </details>
                                            {rrMetrics && (
                                                <div className="mt-4 space-y-3">
                                                    {/* Fila de Métricas Principales */}
                                                    <div className="grid grid-cols-3 gap-3">
                                                        {/* R:R */}
                                                        <div className="bg-white dark:bg-slate-900 p-3 rounded-lg border border-slate-200 dark:border-slate-800 shadow-sm flex flex-col justify-between">
                                                            <div className="text-[10px] uppercase font-bold text-slate-400 mb-1">Ratio R:R</div>
                                                            <div className="flex items-baseline gap-1">
                                                                <span className="text-sm text-slate-500 font-mono">1:</span>
                                                                <span className={`text-xl font-mono font-black ${rrMetrics.ratio < 1 ? 'text-orange-500' : 'text-slate-800 dark:text-white'}`}>
                                                                    {rrMetrics.ratio > 0 ? rrMetrics.ratio.toFixed(2) : '—'}
                                                                </span>
                                                            </div>
                                                        </div>

                                                        {/* BE WR */}
                                                        <div className="bg-white dark:bg-slate-900 p-3 rounded-lg border border-slate-200 dark:border-slate-800 shadow-sm flex flex-col justify-between">
                                                            <div className="text-[10px] uppercase font-bold text-slate-400 mb-1">Win Rate Min.</div>
                                                            <div className="flex items-baseline gap-1">
                                                                <span className="text-xl font-mono font-black text-slate-800 dark:text-white">
                                                                    {rrMetrics.beWr != null ? rrMetrics.beWr.toFixed(1) : '—'}
                                                                </span>
                                                                <span className="text-xs text-slate-500 font-mono">%</span>
                                                            </div>
                                                        </div>

                                                        {/* EVALUACIÓN / EDGE */}
                                                        <div className={`p-3 px-2 rounded-lg border shadow-sm flex flex-col justify-between transition-colors duration-300 relative overflow-hidden ${auditVariant.container}`}>
                                                            <div className="text-[10px] uppercase font-bold opacity-80 mb-1 flex items-center gap-1 z-10 relative">
                                                                <AuditIcon size={12} />
                                                                {auditVariant.message}
                                                            </div>

                                                            <div className="z-10 relative">
                                                                {rrMetrics && rrMetrics.edge != null ? (
                                                                    <>
                                                                        <div className="text-[11px] font-black leading-tight tracking-tight uppercase text-slate-700 dark:text-slate-100">
                                                                            {rrMetrics.edge >= 0 ? `Edge Positivo (+${rrMetrics.edge.toFixed(1)}%)` : `Edge Negativo (${rrMetrics.edge.toFixed(1)}%)`}
                                                                        </div>
                                                                        {rrMetrics.label && (
                                                                            <div className="text-[9px] opacity-80 font-medium mt-0.5">{rrMetrics.label}</div>
                                                                        )}
                                                                    </>
                                                                ) : (
                                                                    <div className="text-xs text-slate-500 dark:text-slate-400 font-medium flex items-center gap-1">
                                                                        <Icons.Activity size={12} />
                                                                        <span>Ejecuta una simulación para evaluar.</span>
                                                                    </div>
                                                                )}
                                                            </div>

                                                            {/* Background Icon Watermark */}
                                                            <div className="absolute -right-2 -bottom-2 opacity-10 pointer-events-none">
                                                                <AuditIcon size={40} />
                                                            </div>
                                                        </div>
                                                    </div>

                                                    {/* Alertas de Auditoría */}
                                                    {rrMetrics && rrMetrics.auditState === 'INSUFFICIENTE' && (
                                                        <div className="bg-slate-100 dark:bg-slate-900/40 border border-slate-300 dark:border-slate-700 rounded-lg p-3 flex gap-3 animate-fade-in text-slate-600 dark:text-slate-300">
                                                            <Icons.HelpCircle size={18} className="text-slate-500 dark:text-slate-400" />
                                                            <div className="text-sm">
                                                                <p className="font-bold">Muestra Insuficiente</p>
                                                                <p>Muestra muy pequeña ({rrMetrics.closedTrades}). Los resultados son aleatorios. Se requieren &gt;30 trades.</p>
                                                            </div>
                                                        </div>
                                                    )}

                                                    {rrMetrics && rrMetrics.auditState === 'FRAGIL' && (
                                                        <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-3 flex gap-3 animate-fade-in text-red-700 dark:text-red-300">
                                                            <Icons.Activity size={18} className="text-red-600 dark:text-red-300" />
                                                            <div className="text-sm">
                                                                <p className="font-bold">Peligro de Barrido</p>
                                                                <p>Peligro de Barrido: El precio retrocede un {(Math.round((rrMetrics.maeRatio || 0) * 1000) / 10).toFixed(1)}% hacia el SL en promedio. Es una estrategia cardíaca.</p>
                                                            </div>
                                                        </div>
                                                    )}

                                                    {/* Mensaje de Alerta Especulativa Extendido */}
                                                    {rrMetrics && rrMetrics.auditState === 'ESPECULATIVO' && (
                                                        <div className="bg-orange-50 dark:bg-orange-900/10 border border-orange-100 dark:border-orange-900/30 rounded-lg p-3 flex gap-3 animate-fade-in">
                                                            <div className="text-orange-500 shrink-0 mt-0.5">
                                                                <Icons.ShieldAlert size={16} />
                                                            </div>
                                                            <div className="text-xs">
                                                                <p className="font-bold text-orange-700 dark:text-orange-400 mb-1">Precaución: Falso Positivo Detectado</p>
                                                                <p className="text-orange-600 dark:text-orange-300/80 leading-relaxed">
                                                                    Tu histórico muestra ganancias, pero el <strong>Wilson Score (95%)</strong> indica que la muestra es insuficiente.
                                                                    Existe una alta probabilidad de que el resultado sea suerte. Aumenta la muestra o el Win Rate.
                                                                </p>
                                                                <div className="mt-2 flex gap-4 font-mono text-[10px] opacity-80">
                                                                    <span>Win Rate Real: <b>{rrMetrics.hist.toFixed(1)}%</b></span>
                                                                    <span>Wilson 95%: <b>{rrMetrics.wilson.toFixed(1)}%</b></span>
                                                                    <span>Necesario: <b>{rrMetrics.beWr.toFixed(1)}%</b></span>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                            <details className="group mt-3 border border-slate-200 dark:border-slate-800 rounded overflow-hidden">
                                                <summary className="flex items-center justify-between p-2 cursor-pointer bg-slate-50 dark:bg-slate-900 text-xs font-bold text-slate-500 hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors select-none">
                                                    <span className="flex items-center gap-2"><Icons.HelpCircle size={12} /> Guía de Clasificación</span>
                                                    <Icons.ChevronDown size={12} className="transition-transform group-open:rotate-180" />
                                                </summary>
                                                <div className="p-3 bg-white dark:bg-slate-950 text-[10px] space-y-1.5 border-t border-slate-200 dark:border-slate-800">
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-bold text-green-700 dark:text-green-400 flex items-center gap-1"><Icons.ShieldCheck size={10} /> Robusto (Excelente)</span>
                                                        <span className="text-slate-500">Wilson 95% &gt; BE</span>
                                                    </div>
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-bold text-orange-500 dark:text-orange-400">Especulativo (Trampa)</span>
                                                        <span className="text-slate-500">Histórico OK, Wilson Mal</span>
                                                    </div>
                                                    <div className="p-2 bg-orange-50 dark:bg-orange-900/20 rounded border border-orange-100 dark:border-orange-900/30 text-orange-800 dark:text-orange-200 italic mb-2">
                                                        Un Edge Especulativo significa que aunque el histórico es bueno, la muestra es muy pequeña para garantizar ganancias futuras según el Wilson Score.
                                                    </div>
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-bold text-slate-600 dark:text-slate-400">Marginal</span>
                                                        <span className="text-slate-500">Edge ≥ 0%</span>
                                                    </div>
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-bold text-red-500 dark:text-red-400">Esperanza Negativa</span>
                                                        <span className="text-slate-500">Edge &lt; 0%</span>
                                                    </div>
                                                    <div className="pt-2 mt-1 border-t border-slate-100 dark:border-slate-800 text-slate-400 italic">
                                                        *Edge = WinRate Histórico - WinRate Break-Even
                                                    </div>
                                                </div>
                                            </details>
                                            <details className="group mt-3 border border-slate-200 dark:border-slate-800 rounded overflow-hidden">
                                                <summary className="flex items-center justify-between p-2 cursor-pointer bg-slate-50 dark:bg-slate-900 text-xs font-bold text-slate-500 hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors select-none">
                                                    <span className="flex items-center gap-2"><Icons.Target size={12} /> Min. Win Rate Referencia</span>
                                                    <Icons.ChevronDown size={12} className="transition-transform group-open:rotate-180" />
                                                </summary>
                                                <div className="p-3 bg-white dark:bg-slate-950 text-[10px] space-y-1.5 border-t border-slate-200 dark:border-slate-800">
                                                    <div className="grid grid-cols-2 gap-2 pb-1 mb-1 border-b border-slate-100 dark:border-slate-800 font-bold text-slate-400">
                                                        <span>Ratio R:R</span>
                                                        <span className="text-right">Min. Win Rate</span>
                                                    </div>
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-mono text-slate-600 dark:text-slate-400">1:1</span>
                                                        <span className="font-mono font-bold text-slate-700 dark:text-slate-300">50.0%</span>
                                                    </div>
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-mono text-slate-600 dark:text-slate-400">1:1.5</span>
                                                        <span className="font-mono font-bold text-slate-700 dark:text-slate-300">40.0%</span>
                                                    </div>
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-mono text-slate-600 dark:text-slate-400">1:2</span>
                                                        <span className="font-mono font-bold text-slate-700 dark:text-slate-300">33.3%</span>
                                                    </div>
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-mono text-slate-600 dark:text-slate-400">1:2.5</span>
                                                        <span className="font-mono font-bold text-slate-700 dark:text-slate-300">28.6%</span>
                                                    </div>
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-mono text-slate-600 dark:text-slate-400">1:3</span>
                                                        <span className="font-mono font-bold text-slate-700 dark:text-slate-300">25.0%</span>
                                                    </div>
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-mono text-slate-600 dark:text-slate-400">1:4</span>
                                                        <span className="font-mono font-bold text-slate-700 dark:text-slate-300">20.0%</span>
                                                    </div>
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-mono text-slate-600 dark:text-slate-400">1:5</span>
                                                        <span className="font-mono font-bold text-slate-700 dark:text-slate-300">16.7%</span>
                                                    </div>
                                                    <div className="pt-2 mt-1 border-t border-slate-100 dark:border-slate-800 text-slate-400 italic">
                                                        *Mínimo para no perder dinero (Break-Even)
                                                    </div>
                                                </div>
                                            </details>
                                        </section>

                                        {/* 4. FILTROS */}
                                        <section className="bg-slate-50 dark:bg-slate-800/50 p-5 rounded-xl border border-slate-200 dark:border-slate-700/50 space-y-3 shadow-sm">
                                            <h3 className="text-sm font-bold text-slate-500 dark:text-slate-400 uppercase mb-2 flex items-center gap-2"><Icons.AlertCircle size={16} /> Filtros de Contexto</h3>

                                            <h4 className="text-xs font-bold text-slate-400 uppercase mt-2 mb-2">Datos institucionales</h4>
                                            <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer hover:text-slate-800 dark:hover:text-slate-200">
                                                <input type="checkbox" checked={useAdrFilter} onChange={(e) => setUseAdrFilter(e.target.checked)} className="accent-blue-500" />
                                                <Icons.Activity size={14} className="text-red-500" /> Evitar Agotamiento ADR (&gt;100%)
                                            </label>
                                            <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer hover:text-slate-800 dark:hover:text-slate-200">
                                                <input type="checkbox" checked={useVolumeFilter} onChange={(e) => setUseVolumeFilter(e.target.checked)} className="accent-blue-500" disabled={!hasExtended || !(csvData[selectedCandleIndex] && csvData[selectedCandleIndex].volume)} />
                                                Volumen Similar (± {volumeTolerance}%)
                                            </label>
                                            <input type="range" min="10" max="100" value={volumeTolerance} onChange={(e) => setVolumeTolerance(parseInt(e.target.value))} className="w-full accent-blue-500 h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer" />
                                            <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer hover:text-slate-800 dark:hover:text-slate-200">
                                                <input type="checkbox" checked={useBuyPressureFilter} onChange={(e) => setUseBuyPressureFilter(e.target.checked)} className="accent-blue-500" disabled={!hasExtended || (csvData[selectedCandleIndex] ? csvData[selectedCandleIndex].buyPressurePct == null : true)} />
                                                Presión Compradora Similar (± {bpTolerance})
                                            </label>
                                            <input type="range" min="1" max="20" value={bpTolerance} onChange={(e) => setBpTolerance(parseInt(e.target.value))} className="w-full accent-blue-500 h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer" />
                                            <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer hover:text-slate-800 dark:hover:text-slate-200">
                                                <input type="checkbox" checked={useDeltaSignFilter} onChange={(e) => setUseDeltaSignFilter(e.target.checked)} className="accent-blue-500" disabled={!hasExtended || (csvData[selectedCandleIndex] ? csvData[selectedCandleIndex].delta == null : true)} />
                                                Misma señal de Delta (compra/venta)
                                            </label>

                                            <div className="pt-2 border-t border-slate-200 dark:border-slate-700/50"></div>

                                            <h4 className="text-xs font-bold text-slate-400 uppercase mt-4 mb-2">Contexto y estructura</h4>
                                            {/* === MARKET REGIME FILTER === */}
                                            <div className={`p-3 rounded-lg border transition-all ${useRegimeFilter ? 'bg-cyan-50 dark:bg-cyan-900/20 border-cyan-300 dark:border-cyan-700' : 'bg-slate-100 dark:bg-slate-900/50 border-slate-200 dark:border-slate-700/50'}`}>
                                                <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer">
                                                    <input type="checkbox" checked={useRegimeFilter} onChange={(e) => setUseRegimeFilter(e.target.checked)} className="accent-cyan-500" />
                                                    <Icons.TrendingUp size={14} className={useRegimeFilter ? 'text-cyan-500' : 'text-slate-400'} />
                                                    <span className="font-bold">Filtro de Régimen (ADX)</span>
                                                </label>
                                                {useRegimeFilter && (
                                                    <div className="mt-2 animate-fade-in space-y-2">
                                                        <div className="flex gap-2 items-center">
                                                            <span className="text-xs text-slate-500">Contexto detectado:</span>
                                                            <span className="text-xs font-mono font-bold text-cyan-700 dark:text-cyan-300">
                                                                {(() => {
                                                                    const candle = csvData[selectedCandleIndex];
                                                                    const adx = candle && typeof candle.adx === 'number' ? candle.adx : null;
                                                                    if (adx == null || !isFinite(adx)) return 'Sin ADX';
                                                                    const isTrend = adx >= adxThreshold;
                                                                    return isTrend
                                                                        ? `TREND (ADX ${adx.toFixed(1)} ≥ ${adxThreshold})`
                                                                        : `RANGE (ADX ${adx.toFixed(1)} < ${adxThreshold})`;
                                                                })()}
                                                            </span>
                                                        </div>
                                                        <div className="flex items-center gap-2">
                                                            <span className="text-[10px] text-slate-500">Umbral ADX:</span>
                                                            <input
                                                                type="range"
                                                                min="15"
                                                                max="40"
                                                                value={adxThreshold}
                                                                onChange={(e) => setAdxThreshold(parseInt(e.target.value))}
                                                                className="flex-1 accent-cyan-500 h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer"
                                                            />
                                                            <span className="text-xs font-mono font-bold text-cyan-600 dark:text-cyan-400 w-8">{adxThreshold}</span>
                                                        </div>
                                                        <p className="text-[9px] text-slate-400">
                                                            ADX &gt; {adxThreshold} = Tendencia fuerte | ADX &lt; {adxThreshold} = Mercado lateral
                                                        </p>
                                                    </div>
                                                )}
                                            </div>
                                            <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer hover:text-slate-800 dark:hover:text-slate-200">
                                                <input type="checkbox" checked={useHtfFilter} onChange={(e) => setUseHtfFilter(e.target.checked)} className="accent-blue-500" disabled={!htfData.length} />
                                                Filtro MTF HTF (SMA200)
                                            </label>
                                            <div className="flex gap-2 items-center">
                                                <span className="text-xs text-slate-500 dark:text-slate-400">Modo</span>
                                                <select value={htfMode} onChange={(e) => setHtfMode(e.target.value)} className="flex-1 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded p-2 text-xs text-slate-900 dark:text-white" disabled={!useHtfFilter || !htfData.length}>
                                                    <option value="DISCARD">Descartar contra-tendencia</option>
                                                    <option value="MARK">Permitir y marcar alto riesgo</option>
                                                </select>
                                            </div>
                                            <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer hover:text-slate-800 dark:hover:text-slate-200">
                                                <input type="checkbox" checked={requireHtf} onChange={(e) => setRequireHtf(e.target.checked)} className="accent-blue-500" disabled={!useHtfFilter || !htfData.length} />
                                                Requerir HTF disponible
                                            </label>
                                            <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer hover:text-slate-800 dark:hover:text-slate-200">
                                                <input type="checkbox" checked={useLtfIntra} onChange={(e) => setUseLtfIntra(e.target.checked)} className="accent-blue-500" disabled={!ltfData.length || !tfMinutes} />
                                                Resolver intra-vela con LTF (casos ambiguos)
                                            </label>
                                            <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer hover:text-slate-800 dark:hover:text-slate-200">
                                                <input type="checkbox" checked={useTimeFilter} onChange={(e) => setUseTimeFilter(e.target.checked)} className="accent-blue-500" />
                                                <Icons.Sun size={14} className="text-yellow-500" /> Mismo Horario (+/- 2h)
                                            </label>
                                            <div className="flex gap-2 items-center">
                                                <span className="text-xs text-slate-500 dark:text-slate-400">Horario</span>
                                                <select value={timeMode} onChange={(e) => setTimeMode(e.target.value)} className="flex-1 bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded p-2 text-xs text-slate-900 dark:text-white">
                                                    <option value="LOCAL">Local</option>
                                                    <option value="UTC">UTC</option>
                                                </select>
                                            </div>
                                            <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer hover:text-slate-800 dark:hover:text-slate-200">
                                                <input type="checkbox" checked={useCooldownFilter} onChange={(e) => setUseCooldownFilter(e.target.checked)} className="accent-blue-500" />
                                                Evitar señales solapadas (enfriamiento)
                                            </label>

                                            <div className="pt-2 border-t border-slate-200 dark:border-slate-700/50"></div>

                                            <h4 className="text-xs font-bold text-slate-400 uppercase mt-4 mb-2">Indicadores retail</h4>
                                            <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer hover:text-slate-800 dark:hover:text-slate-200">
                                                <input type="checkbox" checked={useRsiFilter} onChange={(e) => setUseRsiFilter(e.target.checked)} className="accent-blue-500" />
                                                Buscar RSI Similar (+/- {rsiTolerance})
                                            </label>
                                            <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer hover:text-slate-800 dark:hover:text-slate-200">
                                                <input type="checkbox" checked={useTrendFilter} onChange={(e) => setUseTrendFilter(e.target.checked)} className="accent-blue-500" />
                                                Respetar Tendencia SMA200
                                            </label>
                                            <label className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300 cursor-pointer hover:text-slate-800 dark:hover:text-slate-200">
                                                <input type="checkbox" checked={useVolFilter} onChange={(e) => setUseVolFilter(e.target.checked)} className="accent-blue-500" />
                                                <Icons.Zap size={14} className="text-orange-500" /> Volatilidad Similar (Vela)
                                            </label>

                                            {/* --- BLOQUE DE CÓDIGO UI PARA EL TOGGLE --- */}
                                            <div className="bg-slate-100 dark:bg-slate-900/50 p-3 rounded-lg border border-slate-200 dark:border-slate-700/50 mb-4">
                                                <div className="flex items-center justify-between">
                                                    <div className="flex flex-col">
                                                        <span className="text-xs font-bold text-slate-700 dark:text-slate-300 uppercase flex items-center gap-2">
                                                            {useMacroMode ? <Icons.Map size={14} className="text-purple-500" /> : <Icons.Zap size={14} className="text-orange-500" />}
                                                            {useMacroMode ? 'Modo Análisis Macro' : 'Modo Intradía Rápido'}
                                                        </span>
                                                        <span className="text-[10px] text-slate-500 mt-0.5">
                                                            {useMacroMode
                                                                ? 'Límite extendido a 5,000 velas. Ideal para buscar objetivos estructurales lejanos.'
                                                                : 'Límite estándar de 500 velas. Optimizado para setups del día a día.'}
                                                        </span>
                                                    </div>

                                                    <label className="relative inline-flex items-center cursor-pointer">
                                                        <input
                                                            type="checkbox"
                                                            checked={useMacroMode}
                                                            onChange={(e) => setUseMacroMode(e.target.checked)}
                                                            className="sr-only peer"
                                                        />
                                                        <div className="w-11 h-6 bg-slate-300 peer-focus:outline-none rounded-full peer dark:bg-slate-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                                                    </label>
                                                </div>
                                            </div>

                                            {/* === WALK-FORWARD ANALYSIS TOGGLE === */}
                                            <div className={`p-3 rounded-lg border shadow-sm transition-all ${useWalkForward ? 'bg-indigo-50 dark:bg-indigo-900/20 border-indigo-300 dark:border-indigo-700' : 'bg-slate-100 dark:bg-slate-900/50 border-slate-200 dark:border-slate-700/50'}`}>
                                                <div className="flex items-center justify-between">
                                                    <div className="flex flex-col">
                                                        <span className="text-xs font-bold text-slate-700 dark:text-slate-300 uppercase flex items-center gap-2">
                                                            <Icons.Split size={14} className={useWalkForward ? 'text-indigo-500' : 'text-slate-400'} />
                                                            Walk-Forward Analysis
                                                        </span>
                                                        <span className="text-[10px] text-slate-500 mt-0.5">
                                                            {useWalkForward
                                                                ? `${walkForwardSplit}% entrenamiento / ${100 - walkForwardSplit}% validación`
                                                                : 'Divide datos para validar overfitting'}
                                                        </span>
                                                    </div>

                                                    <label className="relative inline-flex items-center cursor-pointer">
                                                        <input
                                                            type="checkbox"
                                                            checked={useWalkForward}
                                                            onChange={(e) => setUseWalkForward(e.target.checked)}
                                                            className="sr-only peer"
                                                            disabled={csvData.length < 500}
                                                        />
                                                        <div className="w-11 h-6 bg-slate-300 peer-focus:outline-none rounded-full peer dark:bg-slate-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                                                    </label>
                                                </div>
                                                {useWalkForward && (
                                                    <div className="mt-3 animate-fade-in">
                                                        <div className="flex justify-between text-[10px] mb-1">
                                                            <span className="text-indigo-600 dark:text-indigo-400 font-bold">In-Sample ({walkForwardSplit}%)</span>
                                                            <span className="text-orange-600 dark:text-orange-400 font-bold">Out-Sample ({100 - walkForwardSplit}%)</span>
                                                        </div>
                                                        <div className="relative h-3 bg-slate-200 dark:bg-slate-700 rounded-full overflow-hidden">
                                                            <div
                                                                className="h-full bg-indigo-500 transition-all duration-200"
                                                                style={{ width: `${walkForwardSplit}%` }}
                                                            ></div>
                                                            {/* Vertical split line */}
                                                            <div
                                                                className="absolute top-0 bottom-0 w-1 bg-slate-800 dark:bg-white shadow-lg"
                                                                style={{ left: `calc(${walkForwardSplit}% - 2px)` }}
                                                            ></div>
                                                        </div>
                                                        <input
                                                            type="range"
                                                            min="50"
                                                            max="90"
                                                            step="5"
                                                            value={walkForwardSplit}
                                                            onChange={(e) => setWalkForwardSplit(parseInt(e.target.value))}
                                                            className="w-full accent-indigo-500 h-2 bg-transparent appearance-none cursor-pointer mt-2"
                                                        />
                                                    </div>
                                                )}
                                            </div>
                                            <button data-export-exclude="true" onClick={runSimulation} className="w-full mt-4 bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 rounded-lg shadow-lg flex items-center justify-center gap-2 transition-all active:scale-95">
                                                <Icons.Play size={18} /> EJECUTAR ANÁLISIS
                                            </button>
                                        </section>
                                    </div>

                                    {/* COLUMNA DERECHA: RESULTADOS */}
                                    <div id="analysis-results" className="lg:col-span-7 bg-slate-50 dark:bg-slate-950 rounded-xl border border-slate-200 dark:border-slate-800 p-6 relative transition-colors duration-300 shadow-inner">
                                        {!simResult ? (
                                            <div className="absolute inset-0 flex flex-col items-center justify-center text-slate-400 dark:text-slate-600">
                                                <Icons.BarChart3 size={48} className="mb-4 opacity-20" />
                                                <p>Configura los parámetros y ejecuta la simulación.</p>
                                            </div>
                                        ) : simResult.error ? (
                                            <div className="text-red-500 dark:text-red-400 flex items-center gap-2 justify-center h-full"><Icons.AlertCircle /> {simResult.error}</div>
                                        ) : (
                                            <div className="space-y-8 animate-fade-in">

                                                {/* SCORE PRINCIPAL */}
                                                <div className="text-center relative">
                                                    <h2 className="text-sm text-slate-500 font-bold uppercase tracking-widest mb-2">Probabilidad Histórica</h2>
                                                    <div className={`text-6xl font-black leading-[1.2] screenshot-safe-score ${parseFloat(simResult.winRate) >= 60 ? 'text-green-600 dark:text-green-400' :
                                                        parseFloat(simResult.winRate) >= 50 ? 'text-orange-500 dark:text-orange-400' : 'text-red-500 dark:text-red-400'
                                                        }`}>
                                                        {simResult.winRate}%
                                                    </div>

                                                    <div data-export-exclude="true" className="absolute right-0 top-0 flex items-center gap-2">
                                                        <button
                                                            onClick={handleCopyAll}
                                                            disabled={!simResult || (simResult && simResult.error) || copyAllStatus === 'copying'}
                                                            className="bg-slate-900 hover:bg-slate-800 disabled:bg-slate-400 disabled:cursor-not-allowed text-white px-3 py-2 rounded-lg shadow-lg transition-all active:scale-95 disabled:active:scale-100 text-xs font-bold"
                                                            title="Copiar configuración, filtros y resultados"
                                                        >
                                                            {copyAllStatus === 'copying' ? 'Copiando…' : copyAllStatus === 'success' ? 'Copiado' : copyAllStatus === 'error' ? 'Error' : 'Copiar todo'}
                                                        </button>
                                                        <button
                                                            onClick={handleOptimize}
                                                            disabled={isOptimizing}
                                                            className="bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-400 disabled:cursor-not-allowed text-white p-2 rounded-lg shadow-lg transition-all active:scale-95 group disabled:active:scale-100"
                                                            title="Buscar Mejor Combinación de Filtros"
                                                        >
                                                            {isOptimizing ? (
                                                                <Icons.Activity className="animate-spin" size={18} />
                                                            ) : (
                                                                <Icons.Zap size={18} className="group-hover:text-yellow-300 transition-colors" />
                                                            )}
                                                        </button>
                                                    </div>

                                                    <div className="prob-summary text-slate-500 dark:text-slate-400 text-sm mt-3 flex justify-center gap-4">
                                                        <span className="bg-white dark:bg-slate-900 px-3 py-1 rounded border border-slate-200 dark:border-slate-800 shadow-sm" title="Trades Ganadores">Wins: <b className="text-green-600 dark:text-green-400">{simResult.wins}</b></span>
                                                        <span className="bg-white dark:bg-slate-900 px-3 py-1 rounded border border-slate-200 dark:border-slate-800 shadow-sm" title="Trades Perdedores">Losses: <b className="text-red-500 dark:text-red-400">{simResult.losses}</b></span>
                                                        <span className="bg-white dark:bg-slate-900 px-3 py-1 rounded border border-slate-200 dark:border-slate-800 shadow-sm" title="Total de Muestras">Total: <b className="text-blue-600 dark:text-blue-400">{simResult.wins + simResult.losses}</b></span>
                                                        {simResult.wilsonLower95 && (
                                                            <span className="bg-white dark:bg-slate-900 px-3 py-1 rounded border border-slate-200 dark:border-slate-800 shadow-sm" title="Límite inferior Wilson 95%">Wilson 95%: <b className="text-slate-800 dark:text-slate-200">{simResult.wilsonLower95}%</b></span>
                                                        )}
                                                        {(simResult.htfAligned != null && (simResult.htfAligned + simResult.htfOpposed + simResult.htfUnknown) > 0) && (
                                                            <span className="bg-white dark:bg-slate-900 px-3 py-1 rounded border border-slate-200 dark:border-slate-800 shadow-sm" title="MTF HTF">HTF: <b className="text-slate-800 dark:text-slate-200">{simResult.htfAligned}</b> / <b className="text-orange-600 dark:text-orange-400">{simResult.htfOpposed}</b> / <b className="text-slate-500">{simResult.htfUnknown}</b></span>
                                                        )}
                                                        {(simResult.htfFilteredOut != null && simResult.htfFilteredOut > 0) && (
                                                            <span className="bg-white dark:bg-slate-900 px-3 py-1 rounded border border-slate-200 dark:border-slate-800 shadow-sm" title="Filtradas por HTF">HTF filtradas: <b className="text-slate-800 dark:text-slate-200">{simResult.htfFilteredOut}</b></span>
                                                        )}
                                                        {(simResult.ltfAmbiguous != null && simResult.ltfAmbiguous > 0) && (
                                                            <span className="bg-white dark:bg-slate-900 px-3 py-1 rounded border border-slate-200 dark:border-slate-800 shadow-sm" title="Ambigüedad intra-vela">Ambiguas: <b className="text-slate-800 dark:text-slate-200">{simResult.ltfAmbiguous}</b> · Resueltas: <b className="text-slate-800 dark:text-slate-200">{simResult.ltfResolved || 0}</b></span>
                                                        )}
                                                    </div>
                                                </div>

                                                {/* RESULTADOS OPTIMIZACION */}
                                                {optimizationResults && (
                                                    <div className="bg-indigo-50 dark:bg-slate-900/80 p-4 rounded-xl border border-indigo-200 dark:border-indigo-900/50 animate-fade-in mb-6">
                                                        <div className="flex items-center justify-between mb-3">
                                                            <h3 className="text-xs font-bold text-indigo-600 dark:text-indigo-400 uppercase flex items-center gap-2">
                                                                <Icons.Zap size={14} className="text-yellow-500" /> Mejores Configuraciones
                                                            </h3>
                                                            <button onClick={() => setOptimizationResults(null)} className="text-slate-400 hover:text-slate-600 dark:hover:text-slate-200">
                                                                <Icons.Activity size={14} className="rotate-45" />
                                                            </button>
                                                        </div>
                                                        <div className="space-y-2">
                                                            {optimizationResults.map((opt, idx) => (
                                                                <div key={idx}
                                                                    onClick={() => applyOptimization(opt.config)}
                                                                    className={`p-3 rounded-lg border shadow-sm cursor-pointer transition-all flex items-center justify-between group ${opt.isRobust
                                                                        ? 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-200 dark:border-emerald-800 hover:border-emerald-400'
                                                                        : opt.isSpeculative && opt.speculativeType === 'LOOSE'
                                                                            ? 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 hover:border-red-400'
                                                                            : opt.isSpeculative && opt.speculativeType === 'STRICT'
                                                                                ? 'bg-purple-50 dark:bg-purple-900/20 border-purple-200 dark:border-purple-800 hover:border-purple-400'
                                                                                : 'bg-white dark:bg-slate-900 border-slate-200 dark:border-slate-800 hover:border-indigo-400 dark:hover:border-indigo-500'
                                                                        }`}
                                                                >
                                                                    <div className="flex-1">
                                                                        <div className="flex flex-wrap gap-1 mb-1 items-center">
                                                                            {/* Badge de Robustez (nuevo) */}
                                                                            {opt.isRobust && (
                                                                                <span className="text-[9px] font-bold bg-emerald-100 dark:bg-emerald-800 text-emerald-700 dark:text-emerald-300 px-1.5 py-0.5 rounded border border-emerald-200 dark:border-emerald-700 mr-1 flex items-center gap-1">
                                                                                    <Icons.ShieldCheck size={8} /> ★ ROBUSTO
                                                                                </span>
                                                                            )}
                                                                            {/* Badge de Especulativo LOOSE = FRÁGIL (nuevo) */}
                                                                            {opt.isSpeculative && opt.speculativeType === 'LOOSE' && (
                                                                                <span className="text-[9px] font-bold bg-red-100 dark:bg-red-800 text-red-700 dark:text-red-300 px-1.5 py-0.5 rounded border border-red-200 dark:border-red-700 mr-1 flex items-center gap-1">
                                                                                    <Icons.AlertTriangle size={8} /> ⛔ FRÁGIL
                                                                                </span>
                                                                            )}
                                                                            {/* Badge de Especulativo STRICT = PRECISO (nuevo) */}
                                                                            {opt.isSpeculative && opt.speculativeType === 'STRICT' && (
                                                                                <span className="text-[9px] font-bold bg-purple-100 dark:bg-purple-800 text-purple-700 dark:text-purple-300 px-1.5 py-0.5 rounded border border-purple-200 dark:border-purple-700 mr-1 flex items-center gap-1">
                                                                                    <Icons.Target size={8} /> 🎯 PRECISO
                                                                                </span>
                                                                            )}
                                                                            {/* Badge del Tier usado (nuevo) */}
                                                                            {opt.tierLabel && (
                                                                                <span className="text-[9px] font-mono bg-slate-200 dark:bg-slate-700 text-slate-600 dark:text-slate-300 px-1.5 py-0.5 rounded mr-1">
                                                                                    {opt.tierLabel}
                                                                                </span>
                                                                            )}
                                                                            {opt.labels.map((l, i) => (
                                                                                <span key={i} className="text-[10px] bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-300 px-1.5 py-0.5 rounded border border-slate-200 dark:border-slate-700">
                                                                                    {l}
                                                                                </span>
                                                                            ))}
                                                                            {opt.labels.length === 0 && <span className="text-[10px] text-slate-400 italic">Sin Filtros</span>}
                                                                        </div>
                                                                        <div className="text-xs text-slate-500 flex gap-2 flex-wrap">
                                                                            <span className={opt.isRobust ? "font-bold text-emerald-600 dark:text-emerald-400" : ""}>{opt.stats.matches} coincidencias</span>
                                                                            {/* Mostrar valores numéricos usados (nuevo) */}
                                                                            {opt.config.useRsi && <span className="text-slate-400">RSI±{opt.config.rsiTol}</span>}
                                                                            {opt.config.useVol && <span className="text-slate-400">Vol±{opt.config.volTol}%</span>}
                                                                            {opt.config.useBp && <span className="text-slate-400">BP±{opt.config.bpTol}</span>}
                                                                        </div>
                                                                    </div>
                                                                    <div className="text-right">
                                                                        <div className={`text-lg font-bold font-mono ${parseFloat(opt.stats.winRate) >= 60 ? 'text-green-600 dark:text-green-400' : 'text-indigo-600 dark:text-indigo-400'
                                                                            }`}>
                                                                            {opt.stats.winRate}%
                                                                        </div>
                                                                        <div className="text-[10px] text-indigo-500 dark:text-indigo-400 opacity-0 group-hover:opacity-100 transition-opacity">
                                                                            Clic para aplicar
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}

                                                {/* METRICAS SECUNDARIAS */}
                                                <div className="grid grid-cols-2 gap-4">
                                                    {/* SQN CARD - NEW */}
                                                    <div className="bg-white dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 shadow-sm">
                                                        <div className="text-xs text-slate-500 uppercase mb-1 flex items-center gap-2">
                                                            SQN (System Quality)
                                                            {simResult.sqnClassification && (
                                                                <span className={`text-[9px] font-bold px-1.5 py-0.5 rounded ${simResult.sqnClassification === 'SUPERB' ? 'bg-emerald-100 dark:bg-emerald-900 text-emerald-600 dark:text-emerald-300' :
                                                                    simResult.sqnClassification === 'EXCELLENT' ? 'bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300' :
                                                                        simResult.sqnClassification === 'GOOD' ? 'bg-blue-100 dark:bg-blue-900 text-blue-600 dark:text-blue-300' :
                                                                            simResult.sqnClassification === 'AVERAGE' ? 'bg-yellow-100 dark:bg-yellow-900 text-yellow-600 dark:text-yellow-300' :
                                                                                'bg-red-100 dark:bg-red-900 text-red-600 dark:text-red-300'
                                                                    }`}>
                                                                    {simResult.sqnClassification}
                                                                </span>
                                                            )}
                                                        </div>
                                                        {simResult.sqn ? (
                                                            <>
                                                                <div className={`text-2xl font-mono font-bold ${parseFloat(simResult.sqn) >= 2.5 ? 'text-green-600 dark:text-green-400' :
                                                                    parseFloat(simResult.sqn) >= 1.6 ? 'text-blue-600 dark:text-blue-400' :
                                                                        'text-red-600 dark:text-red-400'
                                                                    }`}>{simResult.sqn}</div>
                                                                <div className="grid grid-cols-2 gap-2 mt-2 text-[10px]">
                                                                    <div>
                                                                        <span className="text-slate-500">Expectancy:</span>
                                                                        <span className={`ml-1 font-mono font-bold ${parseFloat(simResult.expectancy) >= 0 ? 'text-green-600' : 'text-red-500'}`}>
                                                                            {simResult.expectancy}%
                                                                        </span>
                                                                    </div>
                                                                    <div>
                                                                        <span className="text-slate-500">SQN₁₀₀:</span>
                                                                        <span className="ml-1 font-mono font-bold text-slate-700 dark:text-slate-200">{simResult.sqnNormalized}</span>
                                                                    </div>
                                                                </div>
                                                                <p className="text-[10px] text-slate-500 mt-2">
                                                                    SQN mide calidad del sistema. SQN₁₀₀ normaliza a 100 trades para comparar.
                                                                </p>
                                                            </>
                                                        ) : (
                                                            <div className="text-slate-400 text-sm">Insuficientes datos (min. 5 trades)</div>
                                                        )}
                                                    </div>
                                                    <div className="bg-white dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 shadow-sm">
                                                        <div className="text-xs text-slate-500 uppercase mb-1">Ratio de Dolor (Pain)</div>
                                                        <div className={`text-2xl font-mono font-bold ${parseFloat(simResult.painRatio) < 50 ? 'text-green-600 dark:text-green-400' : 'text-yellow-500 dark:text-yellow-400'}`}>{simResult.painRatio}%</div>
                                                        <p className="text-[10px] text-slate-500 mt-1">
                                                            {parseFloat(simResult.painRatio) < 50 ? "El precio suele ir directo al TP." : "Prepárate para sufrir antes de ganar."}
                                                        </p>
                                                    </div>
                                                    <div className="bg-white dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 shadow-sm relative overflow-hidden">
                                                        <div className="flex items-center justify-between mb-2">
                                                            <div className="text-xs text-slate-500 uppercase">Duración (Trades Ganadores)</div>
                                                            <button
                                                                onClick={() => setIsDurationModalOpen(true)}
                                                                className="text-[10px] text-blue-600 dark:text-blue-400 hover:underline font-medium"
                                                            >
                                                                Ver distribución
                                                            </button>
                                                        </div>
                                                        <div className="grid grid-cols-3 gap-2 text-center mb-2">
                                                            <div className="bg-slate-50 dark:bg-slate-800 p-2 rounded">
                                                                <div className="text-[10px] text-slate-400 uppercase">Min</div>
                                                                <div className="font-mono font-bold text-slate-700 dark:text-slate-200">{simResult.minDuration}</div>
                                                            </div>
                                                            <div className="bg-blue-50 dark:bg-blue-900/30 p-2 rounded border border-blue-200 dark:border-blue-800">
                                                                <div className="text-[10px] text-blue-500 uppercase">Media</div>
                                                                <div className="font-mono font-bold text-blue-600 dark:text-blue-400">{simResult.avgDuration}</div>
                                                            </div>
                                                            <div className="bg-slate-50 dark:bg-slate-800 p-2 rounded">
                                                                <div className="text-[10px] text-slate-400 uppercase">Max</div>
                                                                <div className="font-mono font-bold text-slate-700 dark:text-slate-200">{simResult.maxDuration}</div>
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center justify-between text-[10px] bg-slate-50 dark:bg-slate-800 p-2 rounded mb-2">
                                                            <span className="text-slate-500">Mediana: <b className="text-slate-700 dark:text-slate-200">{simResult.medianDuration} velas</b></span>
                                                            <span className="text-orange-500">P80: <b className="text-orange-600 dark:text-orange-400">{simResult.p80Duration} velas</b></span>
                                                        </div>
                                                        {simResult.temporalEfficiency && (
                                                            <div className="mt-2 pt-2 border-t border-slate-100 dark:border-slate-800 flex justify-between items-center text-[10px]">
                                                                <span className="text-slate-500 font-bold uppercase flex items-center gap-1"><Icons.Zap size={10} className="text-emerald-500" /> Eficiencia Temporal</span>
                                                                <span className="font-mono font-bold text-emerald-600 dark:text-emerald-400 bg-emerald-50 dark:bg-emerald-900/30 px-1.5 py-0.5 rounded border border-emerald-100 dark:border-emerald-800">
                                                                    {simResult.temporalEfficiency}% ROI / vela
                                                                </span>
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                                {(simResult.weightedWinRateVolume || simResult.weightedWinRateBuyPressure) && (
                                                    <div className="grid grid-cols-2 gap-4 mt-2">
                                                        {simResult.weightedWinRateVolume && (
                                                            <div className="bg-white dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 shadow-sm">
                                                                <div className="text-xs text-slate-500 uppercase mb-1">Win Rate Ponderado por Volumen</div>
                                                                <div className="text-2xl font-mono font-bold text-blue-600 dark:text-blue-400">{simResult.weightedWinRateVolume}%</div>
                                                                <p className="text-[10px] text-slate-500 mt-1">Probabilidad ajustada por intensidad de mercado.</p>
                                                            </div>
                                                        )}
                                                        {simResult.weightedWinRateBuyPressure && (
                                                            <div className="bg-white dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 shadow-sm">
                                                                <div className="text-xs text-slate-500 uppercase mb-1">Win Rate Ponderado por Presión</div>
                                                                <div className="text-2xl font-mono font-bold text-indigo-600 dark:text-indigo-400">{simResult.weightedWinRateBuyPressure}%</div>
                                                                <p className="text-[10px] text-slate-500 mt-1">Probabilidad ajustada por flujo de órdenes.</p>
                                                            </div>
                                                        )}
                                                    </div>
                                                )}

                                                {/* === WALK-FORWARD ANALYSIS RESULTS === */}
                                                {walkForwardResult && (
                                                    <div className="bg-indigo-50 dark:bg-indigo-900/20 p-4 rounded-xl border border-indigo-200 dark:border-indigo-800 shadow-sm animate-fade-in">
                                                        <div className="flex items-center justify-between mb-3">
                                                            <h3 className="text-xs font-bold text-indigo-600 dark:text-indigo-400 uppercase flex items-center gap-2">
                                                                <Icons.Split size={14} /> Walk-Forward Analysis
                                                            </h3>
                                                            <span className="text-[10px] text-slate-500">
                                                                Split: {walkForwardResult.splitDate || `Idx ${walkForwardResult.splitIndex}`}
                                                            </span>
                                                        </div>

                                                        {/* Visual Split Bar */}
                                                        <div className="relative h-2 bg-slate-200 dark:bg-slate-700 rounded-full overflow-visible mb-4">
                                                            <div
                                                                className="h-full bg-indigo-500 rounded-l-full"
                                                                style={{ width: `${walkForwardSplit}%` }}
                                                            ></div>
                                                            <div
                                                                className="h-full bg-orange-500 absolute top-0 right-0 rounded-r-full"
                                                                style={{ width: `${100 - walkForwardSplit}%` }}
                                                            ></div>
                                                            {/* Vertical split line indicator */}
                                                            <div
                                                                className="absolute -top-1 -bottom-1 w-1 bg-slate-800 dark:bg-white rounded shadow-lg"
                                                                style={{ left: `calc(${walkForwardSplit}% - 2px)` }}
                                                            ></div>
                                                        </div>

                                                        <div className="grid grid-cols-2 gap-4">
                                                            {/* In-Sample */}
                                                            <div className="bg-white dark:bg-slate-900 p-3 rounded-lg border border-indigo-200 dark:border-indigo-800">
                                                                <div className="text-[10px] text-indigo-500 uppercase font-bold mb-2 flex items-center gap-1">
                                                                    📊 In-Sample ({walkForwardSplit}%)
                                                                </div>
                                                                {walkForwardResult.inSample.error ? (
                                                                    <div className="text-xs text-red-500">{walkForwardResult.inSample.error}</div>
                                                                ) : (
                                                                    <div className="space-y-1 text-xs">
                                                                        <div className="flex justify-between">
                                                                            <span className="text-slate-500">Win Rate:</span>
                                                                            <span className="font-mono font-bold text-indigo-600 dark:text-indigo-400">{walkForwardResult.inSample.winRate}%</span>
                                                                        </div>
                                                                        <div className="flex justify-between">
                                                                            <span className="text-slate-500">SQN:</span>
                                                                            <span className="font-mono font-bold">{walkForwardResult.inSample.sqn || '—'}</span>
                                                                        </div>
                                                                        <div className="flex justify-between">
                                                                            <span className="text-slate-500">Trades:</span>
                                                                            <span className="font-mono">{walkForwardResult.inSample.closedTrades}</span>
                                                                        </div>
                                                                    </div>
                                                                )}
                                                            </div>

                                                            {/* Out-of-Sample */}
                                                            <div className="bg-white dark:bg-slate-900 p-3 rounded-lg border border-orange-200 dark:border-orange-800">
                                                                <div className="text-[10px] text-orange-500 uppercase font-bold mb-2 flex items-center gap-1">
                                                                    🔮 Out-of-Sample ({100 - walkForwardSplit}%)
                                                                </div>
                                                                {walkForwardResult.outOfSample.error ? (
                                                                    <div className="text-xs text-red-500">{walkForwardResult.outOfSample.error}</div>
                                                                ) : (
                                                                    <div className="space-y-1 text-xs">
                                                                        <div className="flex justify-between">
                                                                            <span className="text-slate-500">Win Rate:</span>
                                                                            <span className="font-mono font-bold text-orange-600 dark:text-orange-400">{walkForwardResult.outOfSample.winRate}%</span>
                                                                        </div>
                                                                        <div className="flex justify-between">
                                                                            <span className="text-slate-500">SQN:</span>
                                                                            <span className="font-mono font-bold">{walkForwardResult.outOfSample.sqn || '—'}</span>
                                                                        </div>
                                                                        <div className="flex justify-between">
                                                                            <span className="text-slate-500">Trades:</span>
                                                                            <span className="font-mono">{walkForwardResult.outOfSample.closedTrades}</span>
                                                                        </div>
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>

                                                        {/* Degradation Indicator */}
                                                        {walkForwardResult.degradation != null && (
                                                            <div className={`mt-3 p-3 rounded-lg border ${walkForwardResult.degradation < 20
                                                                ? 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800'
                                                                : walkForwardResult.degradation < 50
                                                                    ? 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800'
                                                                    : 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800'
                                                                }`}>
                                                                <div className="flex items-center justify-between">
                                                                    <div className="flex items-center gap-2">
                                                                        {walkForwardResult.degradation < 20 ? (
                                                                            <Icons.ShieldCheck className="text-green-500" size={16} />
                                                                        ) : walkForwardResult.degradation < 50 ? (
                                                                            <Icons.AlertTriangle className="text-yellow-500" size={16} />
                                                                        ) : (
                                                                            <Icons.AlertCircle className="text-red-500" size={16} />
                                                                        )}
                                                                        <span className="text-xs font-bold">
                                                                            {walkForwardResult.degradation < 20
                                                                                ? 'Estrategia Robusta'
                                                                                : walkForwardResult.degradation < 50
                                                                                    ? 'Posible Overfitting'
                                                                                    : 'Alto Riesgo de Overfitting'}
                                                                        </span>
                                                                    </div>
                                                                    <span className={`font-mono font-bold ${walkForwardResult.degradation < 20
                                                                        ? 'text-green-600'
                                                                        : walkForwardResult.degradation < 50
                                                                            ? 'text-yellow-600'
                                                                            : 'text-red-600'
                                                                        }`}>
                                                                        {walkForwardResult.degradation > 0 ? '-' : '+'}{Math.abs(walkForwardResult.degradation).toFixed(1)}%
                                                                    </span>
                                                                </div>
                                                                <p className="text-[10px] text-slate-500 mt-1">
                                                                    Degradación SQN = diferencia entre In-Sample y Out-of-Sample. &lt;20% es ideal.
                                                                </p>
                                                            </div>
                                                        )}
                                                    </div>
                                                )}

                                                {/* === MONTE CARLO SIMULATION === */}
                                                <div className="bg-purple-50 dark:bg-purple-900/20 p-4 rounded-xl border border-purple-200 dark:border-purple-800 shadow-sm">
                                                    <div className="flex items-center justify-between mb-3">
                                                        <h3 className="text-xs font-bold text-purple-600 dark:text-purple-400 uppercase flex items-center gap-2">
                                                            🎲 Simulación Monte Carlo
                                                        </h3>
                                                        <div className="flex items-center gap-2">
                                                            <select
                                                                value={monteCarloSimulations}
                                                                onChange={(e) => setMonteCarloSimulations(parseInt(e.target.value))}
                                                                className="text-xs bg-white dark:bg-slate-900 border border-purple-300 dark:border-purple-700 rounded px-2 py-1"
                                                                disabled={isRunningMonteCarlo}
                                                            >
                                                                <option value="500">500 sims</option>
                                                                <option value="1000">1,000 sims</option>
                                                                <option value="5000">5,000 sims</option>
                                                                <option value="10000">10,000 sims</option>
                                                            </select>
                                                            <button
                                                                onClick={runMonteCarlo}
                                                                disabled={isRunningMonteCarlo || !simResult || simResult.error || simResult.closedTrades < 10}
                                                                className="text-xs bg-purple-600 hover:bg-purple-500 disabled:bg-slate-400 text-white font-bold px-3 py-1.5 rounded-lg shadow transition-all flex items-center gap-1"
                                                            >
                                                                {isRunningMonteCarlo ? (
                                                                    <><Icons.Activity size={12} className="animate-spin" /> Calculando...</>
                                                                ) : (
                                                                    <>🎲 Ejecutar</>
                                                                )}
                                                            </button>
                                                        </div>
                                                    </div>

                                                    <p className="text-[10px] text-slate-500 mb-3">
                                                        Reordena tus {simResult?.closedTrades || 0} trades aleatoriamente para calcular el riesgo de ruina por mala suerte.
                                                    </p>

                                                    {monteCarloResult && (
                                                        <div className="animate-fade-in space-y-3">
                                                            {/* Main Stats Grid */}
                                                            <div className="grid grid-cols-3 gap-3">
                                                                {/* Ruin Probability */}
                                                                <div className={`p-3 rounded-lg border ${monteCarloResult.ruinProbability < 1
                                                                    ? 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800'
                                                                    : monteCarloResult.ruinProbability < 5
                                                                        ? 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800'
                                                                        : 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800'
                                                                    }`}>
                                                                    <div className="text-[9px] uppercase font-bold opacity-60">Prob. Ruina</div>
                                                                    <div className={`text-xl font-mono font-black ${monteCarloResult.ruinProbability < 1 ? 'text-green-600' :
                                                                        monteCarloResult.ruinProbability < 5 ? 'text-yellow-600' : 'text-red-600'
                                                                        }`}>
                                                                        {monteCarloResult.ruinProbability.toFixed(1)}%
                                                                    </div>
                                                                </div>

                                                                {/* Worst Drawdown */}
                                                                <div className="bg-white dark:bg-slate-900 p-3 rounded-lg border border-slate-200 dark:border-slate-800">
                                                                    <div className="text-[9px] uppercase font-bold text-slate-400">Peor DD</div>
                                                                    <div className="text-xl font-mono font-black text-red-600 dark:text-red-400">
                                                                        {monteCarloResult.worstDrawdown.toFixed(1)}%
                                                                    </div>
                                                                </div>

                                                                {/* Median Equity */}
                                                                <div className="bg-white dark:bg-slate-900 p-3 rounded-lg border border-slate-200 dark:border-slate-800">
                                                                    <div className="text-[9px] uppercase font-bold text-slate-400">Equity Mediana</div>
                                                                    <div className={`text-xl font-mono font-black ${monteCarloResult.equityPercentiles.p50 >= 100 ? 'text-green-600' : 'text-red-600'
                                                                        }`}>
                                                                        {monteCarloResult.equityPercentiles.p50.toFixed(0)}
                                                                    </div>
                                                                </div>
                                                            </div>

                                                            {/* Drawdown Distribution */}
                                                            <div className="bg-white dark:bg-slate-900 p-3 rounded-lg border border-slate-200 dark:border-slate-800">
                                                                <div className="text-[10px] font-bold text-slate-500 uppercase mb-2">Distribución de Drawdowns</div>
                                                                <div className="grid grid-cols-5 gap-1 text-center text-[10px]">
                                                                    <div>
                                                                        <div className="text-slate-400">P5</div>
                                                                        <div className="font-mono font-bold text-green-600">{monteCarloResult.percentiles.p5.toFixed(1)}%</div>
                                                                    </div>
                                                                    <div>
                                                                        <div className="text-slate-400">P25</div>
                                                                        <div className="font-mono font-bold">{monteCarloResult.percentiles.p25.toFixed(1)}%</div>
                                                                    </div>
                                                                    <div className="bg-purple-50 dark:bg-purple-900/30 rounded">
                                                                        <div className="text-purple-500 font-bold">P50</div>
                                                                        <div className="font-mono font-bold text-purple-600">{monteCarloResult.percentiles.p50.toFixed(1)}%</div>
                                                                    </div>
                                                                    <div>
                                                                        <div className="text-slate-400">P75</div>
                                                                        <div className="font-mono font-bold">{monteCarloResult.percentiles.p75.toFixed(1)}%</div>
                                                                    </div>
                                                                    <div>
                                                                        <div className="text-slate-400">P95</div>
                                                                        <div className="font-mono font-bold text-red-600">{monteCarloResult.percentiles.p95.toFixed(1)}%</div>
                                                                    </div>
                                                                </div>

                                                                {/* Visual DD Bar */}
                                                                <div className="mt-2 relative h-3 bg-slate-200 dark:bg-slate-700 rounded-full overflow-hidden">
                                                                    <div
                                                                        className="absolute h-full bg-green-400"
                                                                        style={{ left: 0, width: `${Math.min(100, Math.abs(monteCarloResult.percentiles.p5))}%` }}
                                                                    ></div>
                                                                    <div
                                                                        className="absolute h-full bg-yellow-400"
                                                                        style={{ left: `${Math.abs(monteCarloResult.percentiles.p5)}%`, width: `${Math.abs(monteCarloResult.percentiles.p50 - monteCarloResult.percentiles.p5)}%` }}
                                                                    ></div>
                                                                    <div
                                                                        className="absolute h-full bg-red-400"
                                                                        style={{ left: `${Math.abs(monteCarloResult.percentiles.p50)}%`, width: `${Math.abs(monteCarloResult.percentiles.p95 - monteCarloResult.percentiles.p50)}%` }}
                                                                    ></div>
                                                                </div>
                                                            </div>

                                                            {/* Equity Distribution */}
                                                            <div className="bg-white dark:bg-slate-900 p-3 rounded-lg border border-slate-200 dark:border-slate-800">
                                                                <div className="text-[10px] font-bold text-slate-500 uppercase mb-2">Distribución de Equity Final</div>
                                                                <div className="grid grid-cols-5 gap-1 text-center text-[10px]">
                                                                    <div>
                                                                        <div className="text-slate-400">P5</div>
                                                                        <div className={`font-mono font-bold ${monteCarloResult.equityPercentiles.p5 >= 100 ? 'text-green-600' : 'text-red-600'}`}>
                                                                            {monteCarloResult.equityPercentiles.p5.toFixed(0)}
                                                                        </div>
                                                                    </div>
                                                                    <div>
                                                                        <div className="text-slate-400">P25</div>
                                                                        <div className="font-mono font-bold">{monteCarloResult.equityPercentiles.p25.toFixed(0)}</div>
                                                                    </div>
                                                                    <div className="bg-purple-50 dark:bg-purple-900/30 rounded">
                                                                        <div className="text-purple-500 font-bold">P50</div>
                                                                        <div className="font-mono font-bold text-purple-600">{monteCarloResult.equityPercentiles.p50.toFixed(0)}</div>
                                                                    </div>
                                                                    <div>
                                                                        <div className="text-slate-400">P75</div>
                                                                        <div className="font-mono font-bold">{monteCarloResult.equityPercentiles.p75.toFixed(0)}</div>
                                                                    </div>
                                                                    <div>
                                                                        <div className="text-slate-400">P95</div>
                                                                        <div className={`font-mono font-bold ${monteCarloResult.equityPercentiles.p95 >= 100 ? 'text-green-600' : 'text-red-600'}`}>
                                                                            {monteCarloResult.equityPercentiles.p95.toFixed(0)}
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            </div>

                                                            <p className="text-[9px] text-slate-400 text-center">
                                                                {monteCarloResult.simCount.toLocaleString()} simulaciones · Punto de ruina: -50% capital
                                                            </p>
                                                        </div>
                                                    )}

                                                    {!monteCarloResult && !isRunningMonteCarlo && (
                                                        <div className="text-center text-slate-400 text-xs py-4">
                                                            Ejecuta la simulación para ver el análisis de riesgo probabilístico.
                                                        </div>
                                                    )}
                                                </div>

                                                {/* MAE INFO */}
                                                <div className="bg-slate-100 dark:bg-slate-900/50 p-4 rounded-lg border border-slate-200 dark:border-slate-800 shadow-sm">
                                                    <h4 className="text-xs font-bold text-orange-500 dark:text-orange-300 uppercase mb-3 flex items-center gap-2"><Icons.Activity size={14} /> Análisis de Drawdown (MAE)</h4>
                                                    <div className="space-y-3 text-sm">
                                                        <div className="flex justify-between">
                                                            <span className="text-slate-500 dark:text-slate-400">Retroceso Promedio en Ganadores:</span>
                                                            <div className="text-right">
                                                                <div className="font-mono text-orange-500 dark:text-orange-300">-{simResult.avgMae}%</div>
                                                                {(() => {
                                                                    const info = getMaePriceInfo(simResult.avgMae);
                                                                    if (!info) return null;
                                                                    const sign = tradeType === 'LONG' ? '-' : '+';
                                                                    return (
                                                                        <div className="text-[10px] text-slate-500 dark:text-slate-400 font-mono">
                                                                            ≈ {formatPrice(info.level)} ({sign}{formatPrice(info.moveAbs)})
                                                                        </div>
                                                                    );
                                                                })()}
                                                            </div>
                                                        </div>
                                                        <div className="flex justify-between">
                                                            <span className="text-slate-500 dark:text-slate-400">Peor Susto Registrado (Max MAE):</span>
                                                            <div className="text-right">
                                                                <div className="font-mono text-red-500 dark:text-red-400">-{simResult.maxMae}%</div>
                                                                {(() => {
                                                                    const info = getMaePriceInfo(simResult.maxMae);
                                                                    if (!info) return null;
                                                                    const sign = tradeType === 'LONG' ? '-' : '+';
                                                                    return (
                                                                        <div className="text-[10px] text-slate-500 dark:text-slate-400 font-mono">
                                                                            ≈ {formatPrice(info.level)} ({sign}{formatPrice(info.moveAbs)})
                                                                        </div>
                                                                    );
                                                                })()}
                                                            </div>
                                                        </div>
                                                        <div className="h-2 bg-slate-200 dark:bg-slate-800 rounded-full mt-2 overflow-hidden relative">
                                                            {/* SL MARKER */}
                                                            <div className="absolute right-0 top-0 bottom-0 w-1 bg-red-600" title="Stop Loss"></div>
                                                            {/* AVG MAE BAR */}
                                                            <div className="h-full bg-orange-500/50 absolute left-0" style={{ width: Math.min(parseFloat(simResult.painRatio), 100) + '%' }}></div>
                                                        </div>
                                                        <div className="text-[10px] text-slate-500 text-right">0% (Entry) -------------------------------------- 100% (SL)</div>
                                                    </div>
                                                </div>

                                                <div className="pt-4 border-t border-slate-200 dark:border-slate-800 text-center">
                                                    <p className="text-slate-500 dark:text-slate-400 text-sm mb-3">¿Te convence la estadística?</p>
                                                    <div className="flex justify-center gap-3 flex-wrap">
                                                        <button onClick={() => setActiveTab('MONITOR')} className="bg-white dark:bg-slate-800 hover:bg-slate-100 dark:hover:bg-slate-700 text-blue-600 dark:text-blue-400 px-6 py-2 rounded-full text-sm font-bold border border-blue-500/30 transition-all shadow-sm">
                                                            Ir al Monitor &rarr;
                                                        </button>
                                                        <button onClick={handleSaveSimulation} className="bg-green-600 hover:bg-green-500 text-white px-6 py-2 rounded-full text-sm font-bold border border-green-500/30 transition-all shadow-sm">
                                                            Guardar simulación
                                                        </button>
                                                        <button onClick={takeScreenshot} className="bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-full text-sm font-bold border border-slate-500/30 transition-all shadow-sm flex items-center gap-2" title="Capturar pantalla">
                                                            <Icons.Camera size={16} />
                                                            <span className="hidden sm:inline">Capturar</span>
                                                        </button>
                                                    </div>
                                                </div>

                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}

                            {/* --- PESTAÑA 2: MONITOR (DOCTOR) --- */}
                            {activeTab === 'MONITOR' && simResult && (
                                <>
                                <div className="max-w-4xl mx-auto animate-fade-in">
                                    <div className="text-center mb-8">
                                        <h2 className="text-2xl font-bold text-slate-800 dark:text-white mb-2">Monitor de Salud del Trade</h2>
                                        <p className="text-slate-500 dark:text-slate-400">Introduce los datos actuales de tu operación para compararlos con la estadística histórica.</p>
                                    </div>

                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
                                        {/* INPUTS ACTUALES */}
                                        <div className="bg-slate-50 dark:bg-slate-800 p-6 rounded-xl border border-slate-200 dark:border-slate-700 shadow-lg">
                                            <div className="flex items-center justify-between mb-4">
                                                <h3 className="text-lg font-bold text-blue-600 dark:text-blue-400 flex items-center gap-2"><Icons.Stethoscope /> Signos Vitales</h3>
                                                <button
                                                    id="btn-sync-live"
                                                    onClick={handleSyncLivePrice}
                                                    className="text-xs bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400 px-3 py-1.5 rounded-lg border border-blue-200 dark:border-blue-800 hover:bg-blue-200 dark:hover:bg-blue-900/50 transition-colors font-bold flex items-center gap-1"
                                                    title={`Sincronizar con Binance (${autoSymbol || 'Symbol'})`}
                                                >
                                                    ⚡ Sincronizar Ahora
                                                </button>
                                            </div>

                                            <div className="space-y-4">
                                                <div>
                                                    <label className="text-sm font-bold text-slate-600 dark:text-slate-300 block mb-1">Precio Actual de Mercado</label>
                                                    <input type="number" value={currentPrice} onChange={(e) => setCurrentPrice(e.target.value)} className="w-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded p-3 text-lg font-mono text-slate-900 dark:text-white focus:border-blue-500 outline-none transition-colors" placeholder="0.0000" />
                                                </div>
                                                <div>
                                                    <label className="text-sm font-bold text-slate-600 dark:text-slate-300 block mb-1">Velas Transcurridas</label>
                                                    <input type="number" value={candlesSinceEntry} onChange={(e) => setCandlesSinceEntry(parseInt(e.target.value))} className="w-full bg-white dark:bg-slate-900 border border-slate-300 dark:border-slate-600 rounded p-3 text-lg font-mono text-slate-900 dark:text-white focus:border-blue-500 outline-none transition-colors" placeholder="0" />
                                                </div>
                                            </div>

                                            {/* --- Combustible Diario (ADR) --- */}
                                            {(() => {
                                                const candle = csvData[selectedCandleIndex];
                                                if (!candle || candle.adrValue == null) return null;

                                                const adrPct = candle.adrFilledPct || 0;
                                                const isExhausted = adrPct > 100;
                                                const currentPriceNum = parseFloat(currentPrice) || 0;

                                                // Calcular espacio restante hacia TP
                                                let roomWarning = null;
                                                const tpVal = parseFloat(takeProfit) || 0;
                                                const slVal = parseFloat(stopLoss) || 0;

                                                if (currentPriceNum > 0 && candle.adrRoomTop && candle.adrRoomBottom) {
                                                    if (tradeType === 'LONG') {
                                                        // Para LONG, el techo estadístico es adrRoomTop
                                                        const distanceToTop = candle.adrRoomTop - currentPriceNum;
                                                        const distanceToTP = tpVal > 0 ? tpVal - currentPriceNum : null;
                                                        if (distanceToTop <= 0 || (distanceToTP && distanceToTop < distanceToTP * 0.3)) {
                                                            roomWarning = {
                                                                type: 'warning',
                                                                msg: `Poco espacio para LONG. Techo ADR: ${candle.adrRoomTop.toFixed(2)}`
                                                            };
                                                        }
                                                    } else {
                                                        // Para SHORT, el suelo estadístico es adrRoomBottom
                                                        const distanceToBottom = currentPriceNum - candle.adrRoomBottom;
                                                        const distanceToTP = tpVal > 0 ? currentPriceNum - tpVal : null;
                                                        if (distanceToBottom <= 0 || (distanceToTP && distanceToBottom < distanceToTP * 0.3)) {
                                                            roomWarning = {
                                                                type: 'warning',
                                                                msg: `Poco espacio para SHORT. Suelo ADR: ${candle.adrRoomBottom.toFixed(2)}`
                                                            };
                                                        }
                                                    }
                                                }

                                                return (
                                                    <div className={`mt-4 p-4 rounded-lg border shadow-sm ${isExhausted ? 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800' : 'bg-white dark:bg-slate-900 border-slate-200 dark:border-slate-800'}`}>
                                                        <div className="flex items-center justify-between mb-3">
                                                            <h4 className="text-sm font-bold text-slate-600 dark:text-slate-300 flex items-center gap-2">
                                                                <Icons.Zap size={14} className={isExhausted ? 'text-red-500' : 'text-orange-500'} />
                                                                Combustible Diario (ADR)
                                                            </h4>
                                                            {isExhausted && (
                                                                <span className="text-[10px] font-bold text-red-600 dark:text-red-400 bg-red-100 dark:bg-red-900/30 px-2 py-0.5 rounded animate-pulse">
                                                                    🔥 AGOTADO
                                                                </span>
                                                            )}
                                                        </div>

                                                        {/* Barra de progreso ADR */}
                                                        <div className="relative h-4 bg-slate-200 dark:bg-slate-700 rounded-full overflow-visible mb-2">
                                                            <div
                                                                className={`h-full rounded-full transition-all duration-500 ${isExhausted ? 'bg-red-500' : adrPct > 80 ? 'bg-orange-500' : 'bg-green-500'}`}
                                                                style={{ width: `${Math.min(adrPct, 100)}%` }}
                                                            ></div>
                                                            {/* Marcador del 100% */}
                                                            <div className="absolute top-0 bottom-0 w-1 bg-slate-500 dark:bg-slate-400 rounded" style={{ left: 'calc(100% - 2px)' }}></div>
                                                        </div>

                                                        <div className="grid grid-cols-3 gap-2 text-xs font-mono mb-2">
                                                            <div className="text-center">
                                                                <div className="text-[10px] text-slate-500">Rango Hoy</div>
                                                                <div className="font-bold text-slate-700 dark:text-slate-200">{candle.currentDayRange != null ? candle.currentDayRange.toFixed(2) : '—'}</div>
                                                            </div>
                                                            <div className="text-center">
                                                                <div className="text-[10px] text-slate-500">ADR Prom.</div>
                                                                <div className="font-bold text-blue-600 dark:text-blue-400">{candle.adrValue != null ? candle.adrValue.toFixed(2) : '—'}</div>
                                                            </div>
                                                            <div className="text-center">
                                                                <div className="text-[10px] text-slate-500">% Usado</div>
                                                                <div className={`font-bold ${isExhausted ? 'text-red-600 dark:text-red-400' : 'text-slate-700 dark:text-slate-200'}`}>{adrPct.toFixed(1)}%</div>
                                                            </div>
                                                        </div>

                                                        {/* Niveles ADR */}
                                                        <div className="grid grid-cols-2 gap-2 text-xs font-mono border-t border-slate-200 dark:border-slate-700 pt-2 mt-2">
                                                            <div className="flex items-center gap-1">
                                                                <span className="text-green-500">▲</span>
                                                                <span className="text-slate-500">Techo:</span>
                                                                <span className="font-bold text-slate-700 dark:text-slate-200">{candle.adrRoomTop != null ? candle.adrRoomTop.toFixed(2) : '—'}</span>
                                                            </div>
                                                            <div className="flex items-center gap-1">
                                                                <span className="text-red-500">▼</span>
                                                                <span className="text-slate-500">Suelo:</span>
                                                                <span className="font-bold text-slate-700 dark:text-slate-200">{candle.adrRoomBottom != null ? candle.adrRoomBottom.toFixed(2) : '—'}</span>
                                                            </div>
                                                        </div>

                                                        {/* Advertencia de espacio limitado */}
                                                        {roomWarning && (
                                                            <div className="mt-3 p-2 bg-orange-50 dark:bg-orange-900/20 border border-orange-200 dark:border-orange-800 rounded text-xs text-orange-700 dark:text-orange-300 flex items-center gap-2">
                                                                <Icons.AlertTriangle size={14} />
                                                                {roomWarning.msg}
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            })()}
                                        </div>


                                        {/* DIAGNOSTICO RESULTADO */}
                                        <div className="space-y-6">
                                            {/* --- RESULTADO FINAL (SI EL TRADE YA CERRÓ) --- */}
                                            {liveTradeStatus && liveTradeStatus.status !== 'ACTIVE' && (
                                                <div className={`p-8 rounded-xl border-2 shadow-xl text-center animate-fade-in ${liveTradeStatus.status === 'WIN'
                                                    ? 'bg-green-50 dark:bg-green-900/30 border-green-500'
                                                    : 'bg-red-50 dark:bg-red-900/30 border-red-500'
                                                    }`}>
                                                    <div className="inline-flex items-center justify-center w-16 h-16 rounded-full mb-4 shadow-sm bg-white dark:bg-slate-800">
                                                        {liveTradeStatus.status === 'WIN'
                                                            ? <Icons.Target className="text-green-500" size={32} />
                                                            : <Icons.AlertTriangle className="text-red-500" size={32} />
                                                        }
                                                    </div>

                                                    <h3 className={`text-3xl font-black mb-2 ${liveTradeStatus.status === 'WIN' ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
                                                        }`}>
                                                        {liveTradeStatus.status === 'WIN' ? '¡TAKE PROFIT ALCANZADO!' : 'STOP LOSS TOCADO'}
                                                    </h3>

                                                    <p className="text-slate-600 dark:text-slate-300 text-lg mb-6 max-w-md mx-auto">
                                                        {liveTradeStatus.status === 'WIN'
                                                            ? 'El precio tocó tu objetivo. Este trade ya finalizó exitosamente según el historial.'
                                                            : 'El precio tocó tu stop loss. Este trade ya se cerró en pérdida según el historial.'
                                                        }
                                                    </p>

                                                    <div className="inline-block bg-white dark:bg-slate-800 rounded-lg p-4 border border-slate-200 dark:border-slate-700 shadow-sm">
                                                        <div className="grid grid-cols-2 gap-x-8 gap-y-2 text-left">
                                                            <div className="text-xs text-slate-500 uppercase">Precio de Salida</div>
                                                            <div className="font-mono font-bold text-slate-800 dark:text-white text-right">{formatPrice(liveTradeStatus.price)}</div>

                                                            <div className="text-xs text-slate-500 uppercase">Fecha Aprox.</div>
                                                            <div className="font-mono font-bold text-slate-800 dark:text-white text-right">
                                                                {liveTradeStatus.date.toLocaleDateString()} {liveTradeStatus.date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            )}

                                            {/* --- DIAGNOSTICO ACTIVO (SOLO SI SIGUE VIVO O NO HAY ESTADO) --- */}
                                            {(!liveTradeStatus || liveTradeStatus.status === 'ACTIVE') && (
                                                <>


                                                    {activeDiagnosis ? (
                                                        <>
                                                            {/* DIAGNOSTICO DE PRECIO */}
                                                            <div className={`p-6 rounded-xl border shadow-lg ${activeDiagnosis.health === 'HEALTHY' ? 'bg-green-100/50 dark:bg-green-900/20 border-green-500/50' :
                                                                activeDiagnosis.health === 'WARNING' ? 'bg-yellow-100/50 dark:bg-yellow-900/20 border-yellow-500/50' :
                                                                    'bg-red-100/50 dark:bg-red-900/20 border-red-500/50'
                                                                }`}>
                                                        <div className="flex items-center justify-between mb-2">
                                                            <h4 className={`text-lg font-bold ${activeDiagnosis.health === 'HEALTHY' ? 'text-green-600 dark:text-green-400' :
                                                                activeDiagnosis.health === 'WARNING' ? 'text-yellow-600 dark:text-yellow-400' :
                                                                    'text-red-600 dark:text-red-400'
                                                                }`}>
                                                                {activeDiagnosis.health === 'HEALTHY' ? 'ESTADO SALUDABLE' :
                                                                    activeDiagnosis.health === 'WARNING' ? 'PRECAUCIÓN' : 'CRÍTICO'}
                                                            </h4>
                                                            <span className="font-mono text-slate-700 dark:text-white bg-white dark:bg-slate-900/50 px-2 py-1 rounded shadow-sm border border-slate-200 dark:border-transparent">
                                                                PnL: {activeDiagnosis.pnlPercent > 0 ? '+' : ''}{activeDiagnosis.pnlPercent.toFixed(2)}%
                                                            </span>
                                                        </div>
                                                        <p className="text-sm text-slate-600 dark:text-slate-300 leading-relaxed">
                                                            {activeDiagnosis.msg}
                                                        </p>

                                                        {/* BARRA VISUAL DE RIESGO */}
                                                        {activeDiagnosis.pnlPercent < 0 && (
                                                            <div className="mt-6">
                                                                <div className="flex justify-between text-xs text-slate-500 mb-1">
                                                                    <span>Entrada</span>
                                                                    <span>Max MAE Histórico</span>
                                                                    <span>Stop Loss</span>
                                                                </div>
                                                                <div className="h-4 bg-slate-200 dark:bg-slate-900 rounded-full relative border border-slate-300 dark:border-slate-700 overflow-hidden">
                                                                    {/* Zonas */}
                                                                    <div className="absolute left-0 h-full bg-green-500/20" style={{ width: (parseFloat(simResult.avgMae) / parseFloat(simResult.riskDistPercent)) * 100 + '%' }}></div>
                                                                    <div className="absolute h-full bg-yellow-500/20" style={{
                                                                        left: (parseFloat(simResult.avgMae) / parseFloat(simResult.riskDistPercent)) * 100 + '%',
                                                                        width: (((parseFloat(simResult.maxMae) - parseFloat(simResult.avgMae)) / parseFloat(simResult.riskDistPercent)) * 100) + '%'
                                                                    }}></div>

                                                                    {/* Indicador Actual */}
                                                                    <div className="absolute top-0 bottom-0 w-1 bg-slate-800 dark:bg-white shadow-[0_0_10px_rgba(0,0,0,0.5)] dark:shadow-[0_0_10px_white] transition-all duration-500" style={{
                                                                        left: Math.min((activeDiagnosis.drawdownPercent / parseFloat(simResult.riskDistPercent)) * 100, 100) + '%'
                                                                    }}></div>
                                                                </div>
                                                                <div className="text-center text-[10px] text-slate-500 mt-1">La barra es tu drawdown actual</div>
                                                            </div>
                                                        )}
                                                    </div>

                                                    {/* DIAGNOSTICO DE TIEMPO - SEMÁFORO INTELIGENTE */}
                                                    <div className={`p-4 rounded-xl border shadow-sm ${activeDiagnosis.timeStatus === 'EARLY' ? 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800' :
                                                        activeDiagnosis.timeStatus === 'DECISION' ? 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800' :
                                                            'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800'
                                                        }`}>
                                                        <div className="flex items-center gap-3 mb-3">
                                                            <div className={`w-4 h-4 rounded-full shrink-0 ${activeDiagnosis.timeStatus === 'EARLY' ? 'bg-green-500' :
                                                                activeDiagnosis.timeStatus === 'DECISION' ? 'bg-yellow-500' :
                                                                    'bg-red-500 animate-pulse'
                                                                }`}></div>
                                                            <div>
                                                                <h5 className={`font-bold text-sm ${activeDiagnosis.timeStatus === 'EARLY' ? 'text-green-700 dark:text-green-400' :
                                                                    activeDiagnosis.timeStatus === 'DECISION' ? 'text-yellow-700 dark:text-yellow-400' :
                                                                        'text-red-700 dark:text-red-400'
                                                                    }`}>
                                                                    {activeDiagnosis.timeStatus === 'EARLY' ? 'FASE TEMPRANA' :
                                                                        activeDiagnosis.timeStatus === 'DECISION' ? 'FASE DE DECISIÓN' :
                                                                            'TIME STOP'}
                                                                </h5>
                                                            </div>
                                                            <div className="ml-auto text-right">
                                                                <div className="font-mono text-sm font-bold text-slate-700 dark:text-slate-200">{candlesSinceEntry} <span className="text-[10px] text-slate-400">velas</span></div>
                                                            </div>
                                                        </div>

                                                        <p className="text-xs text-slate-600 dark:text-slate-300 mb-3">
                                                            {activeDiagnosis.timeMsg}
                                                        </p>

                                                        {/* BARRA VISUAL DE TIEMPO */}
                                                        <div className="mt-3">
                                                            <div className="flex justify-between text-[9px] text-slate-500 mb-1">
                                                                <span>0</span>
                                                                <span className="text-green-600">Mediana: {activeDiagnosis.median}</span>
                                                                <span className="text-orange-600">P80: {activeDiagnosis.p80}</span>
                                                                <span>Max: {simResult.maxDuration}</span>
                                                            </div>
                                                            <div className="h-3 bg-slate-200 dark:bg-slate-700 rounded-full relative overflow-hidden flex">
                                                                {/* Zona Verde */}
                                                                <div className="h-full bg-green-400/50" style={{ width: (activeDiagnosis.median / simResult.maxDuration) * 100 + '%' }}></div>
                                                                {/* Zona Amarilla */}
                                                                <div className="h-full bg-yellow-400/50" style={{ width: ((activeDiagnosis.p80 - activeDiagnosis.median) / simResult.maxDuration) * 100 + '%' }}></div>
                                                                {/* Zona Roja */}
                                                                <div className="h-full bg-red-400/50 flex-1"></div>
                                                                {/* Indicador Actual */}
                                                                <div
                                                                    className="absolute top-0 bottom-0 w-1 bg-slate-900 dark:bg-white shadow-lg transition-all duration-300"
                                                                    style={{ left: Math.min((candlesSinceEntry / simResult.maxDuration) * 100, 100) + '%' }}
                                                                ></div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                        </>
                                                    ) : (
                                                        <div className="h-full flex flex-col items-center justify-center text-slate-400 dark:text-slate-600 border-2 border-dashed border-slate-300 dark:border-slate-800 rounded-xl">
                                                            <Icons.Activity size={32} className="mb-2 opacity-50" />
                                                            <p className="text-sm">Introduce precio y tiempo para diagnosticar.</p>
                                                        </div>
                                                    )}

                                                </>
                                            )}
                                        </div>
                                    </div>
                                </div>

                                {(!liveTradeStatus || liveTradeStatus.status === 'ACTIVE') && (
                                    <div className="w-full mt-8 animate-fade-in">
                                        <HealthChart
                                            csvData={csvData}
                                            liveHistory={liveHistory}
                                            entryIndex={selectedCandleIndex}
                                            candlesSinceEntry={candlesSinceEntry}
                                            tfMinutes={tfMinutes}
                                            simResult={simResult}
                                            tradeType={tradeType}
                                            entryPrice={entryPrice}
                                            stopLoss={stopLoss}
                                            takeProfit={takeProfit}
                                            currentPrice={currentPrice}
                                            liveTradeStatus={liveTradeStatus}
                                        />
                                    </div>
                                )}
                                </>
                            )}

                            {activeTab === 'SAVES' && (
                                <div className="max-w-5xl mx-auto animate-fade-in">
                                    <div className="text-center mb-8">
                                        <h2 className="text-2xl font-bold text-slate-800 dark:text-white mb-2">Simulaciones Guardadas</h2>
                                        <p className="text-slate-500 dark:text-slate-400">Resumen de métricas almacenadas en este equipo.</p>
                                    </div>
                                    <div className="flex justify-end mb-4">
                                        <button onClick={refreshSavedSims} className="bg-white dark:bg-slate-800 hover:bg-slate-100 dark:hover:bg-slate-700 text-slate-700 dark:text-slate-200 px-4 py-2 rounded-lg text-sm font-medium border border-slate-200 dark:border-slate-700 transition-all shadow-sm">
                                            Actualizar lista
                                        </button>
                                    </div>
                                    {(!savedSims || savedSims.length === 0) ? (
                                        <div className="h-64 flex flex-col items-center justify-center text-slate-400 dark:text-slate-600 border-2 border-dashed border-slate-300 dark:border-slate-800 rounded-xl">
                                            <Icons.Activity size={32} className="mb-2 opacity-50" />
                                            <p className="text-sm">No hay simulaciones guardadas.</p>
                                        </div>
                                    ) : (
                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                            {savedSims.map(item => (
                                                <div key={item.id} className="bg-white dark:bg-slate-900 rounded-xl border border-slate-200 dark:border-slate-800 shadow-sm overflow-hidden flex flex-col transition-all hover:shadow-md">
                                                    {/* Cabecera */}
                                                    <div className="p-4 border-b border-slate-100 dark:border-slate-800 flex items-center justify-between bg-slate-50/50 dark:bg-slate-800/30">
                                                        <div>
                                                            <div className="text-lg font-bold text-slate-800 dark:text-white leading-tight">{item.name}</div>
                                                            <div className="text-[10px] uppercase tracking-wider font-semibold text-slate-400 dark:text-slate-500 mt-1 flex items-center gap-1">
                                                                <Icons.Calendar size={10} />
                                                                {new Date(item.createdAt).toLocaleString()}
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center gap-2">
                                                            <button onClick={() => editSavedSimName(item.id)} className="p-2 text-slate-400 hover:text-indigo-600 dark:hover:text-indigo-400 transition-colors" title="Editar nombre">
                                                                <Icons.Edit2 size={16} />
                                                            </button>
                                                            <button onClick={() => deleteSavedSim(item.id)} className="p-2 text-slate-400 hover:text-red-600 dark:hover:text-red-400 transition-colors" title="Eliminar">
                                                                <Icons.Trash2 size={16} />
                                                            </button>
                                                        </div>
                                                    </div>

                                                    <div className="p-5 space-y-5 flex-1">
                                                        {/* Métricas Principales */}
                                                        <div className="flex items-end justify-between gap-4">
                                                            <div className="flex-1">
                                                                <div className="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500 mb-1">Rendimiento Principal</div>
                                                                <div className="flex items-baseline gap-2">
                                                                    <span className="text-3xl font-black text-slate-800 dark:text-white">{item.metrics.winRate}%</span>
                                                                    <span className="text-sm font-bold text-slate-400 dark:text-slate-500">WR</span>
                                                                </div>
                                                            </div>
                                                            <div className="text-right">
                                                                <div className="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500 mb-1">Muestras</div>
                                                                <div className="text-xl font-bold text-slate-700 dark:text-slate-300">{item.metrics.matches} <span className="text-xs font-normal text-slate-400">trades</span></div>
                                                            </div>
                                                        </div>

                                                        {/* Bloque de Validación Walk-Forward */}
                                                        {item.walkForwardMetrics && (
                                                            <div className="p-3 rounded-lg bg-indigo-50/50 dark:bg-indigo-900/10 border border-indigo-100 dark:border-indigo-900/30">
                                                                <div className="flex items-center justify-between mb-2">
                                                                    <div className="text-[10px] uppercase font-bold text-indigo-600 dark:text-indigo-400 flex items-center gap-1">
                                                                        <Icons.Shield size={10} /> Validación Walk-Forward
                                                                    </div>
                                                                    <div className={`text-[10px] font-bold px-1.5 py-0.5 rounded-full ${
                                                                        item.walkForwardMetrics.degradation < 20 ? 'bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400' :
                                                                        item.walkForwardMetrics.degradation < 50 ? 'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-400' :
                                                                        'bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400'
                                                                    }`}>
                                                                        {item.walkForwardMetrics.degradation}% DEGRADACIÓN
                                                                    </div>
                                                                </div>
                                                                <div className="grid grid-cols-2 gap-4">
                                                                    <div>
                                                                        <div className="text-[9px] text-slate-500 uppercase font-semibold">In-Sample (IS)</div>
                                                                        <div className="text-xs font-bold text-slate-700 dark:text-slate-300">WR: {item.walkForwardMetrics.inSample?.winRate}% · SQN: {item.walkForwardMetrics.inSample?.sqn}</div>
                                                                    </div>
                                                                    <div className="text-right">
                                                                        <div className="text-[9px] text-slate-500 uppercase font-semibold">Out-of-Sample (OOS)</div>
                                                                        <div className="text-xs font-bold text-slate-700 dark:text-slate-300">WR: {item.walkForwardMetrics.outOfSample?.winRate}% · SQN: {item.walkForwardMetrics.outOfSample?.sqn}</div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        )}

                                                        {/* Rejilla de Métricas Secundarias */}
                                                        <div className="grid grid-cols-3 gap-3">
                                                            <div className="space-y-1">
                                                                <div className="text-[9px] uppercase font-bold text-slate-400 dark:text-slate-500">Riesgo (MAE)</div>
                                                                <div className="text-xs font-bold text-slate-700 dark:text-slate-300">Max: {item.metrics.maxMae}%</div>
                                                                <div className="text-[10px] text-slate-500">Avg: {item.metrics.avgMae}%</div>
                                                            </div>
                                                            <div className="space-y-1">
                                                                <div className="text-[9px] uppercase font-bold text-slate-400 dark:text-slate-500">Esfuerzo</div>
                                                                <div className="text-xs font-bold text-slate-700 dark:text-slate-300">Pain: {item.metrics.painRatio}%</div>
                                                                <div className="text-[10px] text-slate-500">Dist: {item.metrics.riskDistPercent}%</div>
                                                            </div>
                                                            <div className="space-y-1 text-right">
                                                                <div className="text-[9px] uppercase font-bold text-slate-400 dark:text-slate-500">Tiempo</div>
                                                                <div className="text-xs font-bold text-slate-700 dark:text-slate-300">{item.metrics.avgDuration} velas</div>
                                                                <div className="text-[10px] text-slate-500">promedio</div>
                                                            </div>
                                                        </div>

                                                        {/* Contexto de Mercado (Snapshot) */}
                                                        {item.targetCandle && (
                                                            <details className="group border border-slate-100 dark:border-slate-800 rounded-lg overflow-hidden">
                                                                <summary className="list-none p-2 bg-slate-50 dark:bg-slate-800/50 text-[10px] font-bold text-slate-500 dark:text-slate-400 cursor-pointer flex items-center justify-between hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors">
                                                                    <span className="flex items-center gap-1.5"><Icons.Eye size={12} /> CONTEXTO DE MERCADO</span>
                                                                    <Icons.ChevronDown size={12} className="group-open:rotate-180 transition-transform" />
                                                                </summary>
                                                                <div className="p-3 grid grid-cols-2 gap-y-2 text-[11px] border-t border-slate-100 dark:border-slate-800 bg-white dark:bg-slate-900/50">
                                                                    <div className="col-span-2 text-slate-400 mb-1 border-b border-slate-50 dark:border-slate-800 pb-1">
                                                                        Vela: <span className="font-mono text-slate-600 dark:text-slate-300">{item.targetCandle.datetime}</span>
                                                                    </div>
                                                                    <div className="flex justify-between px-1">
                                                                        <span className="text-slate-400">Precio:</span>
                                                                        <span className="font-bold text-slate-700 dark:text-slate-200">{item.targetCandle.close}</span>
                                                                    </div>
                                                                    <div className="flex justify-between px-1">
                                                                        <span className="text-slate-400">RSI:</span>
                                                                        <span className="font-bold text-slate-700 dark:text-slate-200">{item.targetCandle.rsi?.toFixed(1) || '—'}</span>
                                                                    </div>
                                                                    <div className="flex justify-between px-1">
                                                                        <span className="text-slate-400">SMA200:</span>
                                                                        <span className={`font-bold ${item.targetCandle.close > item.targetCandle.sma200 ? 'text-green-500' : 'text-red-500'}`}>
                                                                            {item.targetCandle.close > item.targetCandle.sma200 ? 'Encima' : 'Debajo'}
                                                                        </span>
                                                                    </div>
                                                                    <div className="flex justify-between px-1">
                                                                        <span className="text-slate-400">Volatilidad:</span>
                                                                        <span className="font-bold text-slate-700 dark:text-slate-200">{item.targetCandle.bodySizePct?.toFixed(2)}%</span>
                                                                    </div>
                                                                </div>
                                                            </details>
                                                        )}

                                                        {/* Badges de Filtros (Footer de Tarjeta) */}
                                                        <div className="flex flex-wrap gap-1.5 pt-2">
                                                            {item.params && (
                                                                <>
                                                                    <span className="px-1.5 py-0.5 rounded bg-slate-100 dark:bg-slate-800 text-[9px] font-bold text-slate-600 dark:text-slate-400 border border-slate-200 dark:border-slate-700">
                                                                        {item.params.tradeType}
                                                                    </span>
                                                                    {/* Badges de Filtros Activos */}
                                                                    {item.params.rsi?.useRsiFilter && <span className="px-1.5 py-0.5 rounded bg-purple-50 dark:bg-purple-900/20 text-[9px] font-medium text-purple-600 dark:text-purple-400 border border-purple-100 dark:border-purple-800/50">RSI</span>}
                                                                    {item.params.trend?.useTrendFilter && <span className="px-1.5 py-0.5 rounded bg-indigo-50 dark:bg-indigo-900/20 text-[9px] font-medium text-indigo-600 dark:text-indigo-400 border border-indigo-100 dark:border-indigo-800/50">Trend</span>}
                                                                    {item.params.time?.useTimeFilter && <span className="px-1.5 py-0.5 rounded bg-amber-50 dark:bg-amber-900/20 text-[9px] font-medium text-amber-600 dark:text-amber-400 border border-amber-100 dark:border-amber-800/50">Time</span>}
                                                                    {item.params.volBody?.useVolFilter && <span className="px-1.5 py-0.5 rounded bg-rose-50 dark:bg-rose-900/20 text-[9px] font-medium text-rose-600 dark:text-rose-400 border border-rose-100 dark:border-rose-800/50">Vol</span>}
                                                                    {item.params.mtf?.useHtfFilter && <span className="px-1.5 py-0.5 rounded bg-cyan-50 dark:bg-cyan-900/20 text-[9px] font-medium text-cyan-600 dark:text-cyan-400 border border-cyan-100 dark:border-cyan-800/50">HTF</span>}
                                                                    {item.params.mtf?.useLtfIntra && <span className="px-1.5 py-0.5 rounded bg-teal-50 dark:bg-teal-900/20 text-[9px] font-medium text-teal-600 dark:text-teal-400 border border-teal-100 dark:border-teal-800/50">LTF</span>}
                                                                </>
                                                            )}
                                                        </div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            )}

                        </div>
                    </div>
                    <div className="text-center text-slate-500 dark:text-slate-600 text-xs mt-6">Luis Trading Systems © 2025 - All Analysis Local & Private</div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
    <!-- Script de gestión de tema centralizado -->
    <script src="../theme.js"></script>
</body>

</html>
